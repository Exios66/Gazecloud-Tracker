<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Eye Tracking Recorder & Analysis Dashboard</title>
  <!-- GazeCloudAPI for live tracking -->
  <script src="https://api.gazerecorder.com/GazeCloudAPI.js"></script>
  <!-- Chart.js for visualizations -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
  <!-- PapaParse for CSV processing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
  <style>
    :root {
      /* Light theme variables */
      --bg-primary: #f5f5f5;
      --bg-secondary: #ffffff;
      --text-primary: #333333;
      --text-secondary: #666666;
      --border-color: #dddddd;
      --shadow-color: rgba(0, 0, 0, 0.1);
      --accent-color: #4a90e2;
      --success-color: #2ecc71;
      --warning-color: #f1c40f;
      --error-color: #e74c3c;
      --chart-bg: rgba(255, 255, 255, 0.9);
      --notification-bg: rgba(255, 255, 255, 0.95);
    }

    [data-theme="dark"] {
      /* Dark theme variables */
      --bg-primary: #1a1a1a;
      --bg-secondary: #2d2d2d;
      --text-primary: #ffffff;
      --text-secondary: #cccccc;
      --border-color: #404040;
      --shadow-color: rgba(0, 0, 0, 0.3);
      --accent-color: #64b5f6;
      --success-color: #66bb6a;
      --warning-color: #ffd54f;
      --error-color: #ef5350;
      --chart-bg: rgba(45, 45, 45, 0.9);
      --notification-bg: rgba(45, 45, 45, 0.95);
    }

    /* Theme transition */
    * {
      transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
    }

    body {
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--bg-primary);
      color: var(--text-primary);
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
    }

    .theme-toggle {
      background: var(--bg-secondary);
      border: 2px solid var(--border-color);
      border-radius: 20px;
      padding: 5px 15px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.9em;
      color: var(--text-primary);
      transition: transform 0.2s ease;
    }

    .theme-toggle:hover {
      transform: scale(1.05);
    }

    .theme-toggle:active {
      transform: scale(0.95);
    }

    h1, h2, h3 {
      color: var(--text-primary);
      margin: 0;
    }

    hr {
      margin: 40px 0;
      border: none;
      border-top: 1px solid var(--border-color);
    }

    button {
      background: var(--bg-secondary);
      color: var(--text-primary);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      padding: 10px 20px;
      font-size: 1em;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    button:hover {
      background: var(--accent-color);
      color: white;
      border-color: var(--accent-color);
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    #liveData, #debugLog {
      background-color: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
      box-shadow: 0 2px 8px var(--shadow-color);
    }

    #liveData {
      min-height: 50px;
    }

    #debugLog {
      max-height: 200px;
      overflow-y: auto;
      font-family: 'Consolas', monospace;
      font-size: 0.9em;
      white-space: pre-wrap;
    }

    .file-input, .stats-container, .chart-container {
      background: var(--bg-secondary);
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 12px var(--shadow-color);
      margin-bottom: 30px;
      border: 1px solid var(--border-color);
    }

    .stats-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
    }

    .stat-card {
      background: var(--bg-secondary);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 6px var(--shadow-color);
      border: 1px solid var(--border-color);
    }

    .chart-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      justify-content: center;
    }

    .chart-toggle {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      opacity: 0.7;
    }

    .chart-toggle.active {
      opacity: 1;
      transform: scale(1.05);
      box-shadow: 0 4px 12px var(--shadow-color);
    }

    /* Notification system */
    .notification-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }

    .notification {
      background: var(--notification-bg);
      color: var(--text-primary);
      padding: 15px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px var(--shadow-color);
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      pointer-events: auto;
      animation: slideIn 0.3s ease forwards;
      max-width: 300px;
      border-left: 4px solid var(--accent-color);
    }

    .notification.success { border-color: var(--success-color); }
    .notification.warning { border-color: var(--warning-color); }
    .notification.error { border-color: var(--error-color); }

    .notification.fade-out {
      animation: slideOut 0.3s ease forwards;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* Chart theme adaptations */
    .chart-container {
      background: var(--chart-bg);
    }

    canvas {
      border-radius: 8px;
    }

    .live-data-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      padding: 15px;
      background: var(--bg-secondary);
      border-radius: 8px;
      box-shadow: 0 2px 8px var(--shadow-color);
    }
    
    .data-section {
      padding: 10px;
      border-left: 3px solid var(--accent-color);
    }
    
    .data-value {
      font-family: 'Consolas', monospace;
      font-weight: 600;
      color: var(--text-primary);
    }
    
    .data-value.good { color: var(--success-color); }
    .data-value.poor { color: var(--error-color); }
    .data-value.calibrating { color: var(--warning-color); }
    .data-value.recording { color: var(--success-color); }
    .data-value.idle { color: var(--text-secondary); }
    
    #liveData {
      margin: 20px 0;
      transition: all 0.3s ease;
    }

    .calibration-message {
      background: var(--bg-secondary);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px var(--shadow-color);
      margin: 20px 0;
      border-left: 4px solid var(--accent-color);
    }
    
    .calibration-message.error {
      border-left-color: var(--error-color);
    }
    
    .calibration-message h3 {
      margin: 0 0 15px 0;
      color: var(--text-primary);
    }
    
    .calibration-message ol,
    .calibration-message ul {
      margin: 10px 0;
      padding-left: 25px;
    }
    
    .calibration-message li {
      margin: 8px 0;
      color: var(--text-secondary);
    }

    .initialization-steps {
      margin: 15px 0;
    }
    
    .step {
      display: flex;
      align-items: center;
      margin: 10px 0;
      gap: 10px;
    }
    
    .step-indicator {
      font-size: 1.2em;
    }
    
    .calibration-progress {
      margin: 20px 0;
    }
    
    .progress-bar {
      height: 6px;
      background: var(--border-color);
      border-radius: 3px;
      overflow: hidden;
    }
    
    .progress-indicator {
      height: 100%;
      background: var(--accent-color);
      width: 0%;
      animation: progress 30s linear;
    }
    
    @keyframes progress {
      from { width: 0%; }
      to { width: 100%; }
    }
    
    .calibration-message ol li {
      opacity: 0.6;
      transition: opacity 0.3s ease;
    }
    
    .calibration-message ol li.active {
      opacity: 1;
      color: var(--text-primary);
      font-weight: 600;
    }
  </style>
  <script>
    /********** LIVE EYE TRACKING SECTION **********/
    let recordedData = [];
    let tracking = false;
    let lastUpdate = 0;
    let calibrationAttempts = 0;
    let isCalibrating = false;
    let dataCollectionReady = false;
    let lastDataPoint = null;
    const UPDATE_INTERVAL = 50; // ms
    const MAX_RECORDED_POINTS = 10000;
    const MAX_CALIBRATION_ATTEMPTS = 3;
    const CALIBRATION_TIMEOUT = 30000; // 30 seconds
    const MIN_DATA_INTERVAL = 16; // Minimum interval between data points (ms)
    const DATA_QUALITY_THRESHOLD = 0.6; // Minimum confidence threshold

    // Update UI state
    function updateUIState(isRecording) {
      try {
        const startBtn = document.querySelector('button[onclick="startTracking()"]');
        const stopBtn = document.querySelector('button[onclick="stopTracking()"]');
        const exportBtn = document.querySelector('button[onclick="exportCSV()"]');
        const clearBtn = document.querySelector('button[onclick="clearData()"]');
        
        if (startBtn) startBtn.disabled = isRecording;
        if (stopBtn) stopBtn.disabled = !isRecording;
        if (exportBtn) exportBtn.disabled = !recordedData.length;
        if (clearBtn) clearBtn.disabled = !recordedData.length;
      } catch (error) {
        console.error("Error updating UI state:", error);
      }
    }

    // Enhanced logging with severity levels
    function logMessage(message, level = 'info') {
      try {
        const logDiv = document.getElementById("debugLog");
        const timestamp = new Date().toLocaleTimeString();
        const logLevels = {
          error: 'üî¥',
          warning: 'üü°',
          success: 'üü¢',
          info: '‚ÑπÔ∏è'
        };
        const logEntry = `[${timestamp}] ${logLevels[level] || '‚ÑπÔ∏è'} ${message}\n`;
        
        logDiv.textContent += logEntry;
        logDiv.scrollTop = logDiv.scrollHeight;
        
        // Console logging with appropriate methods
        switch(level) {
          case 'error':
            console.error(message);
            break;
          case 'warning':
            console.warn(message);
            break;
          default:
            console.log(message);
        }
      } catch (error) {
        console.error("Error in logMessage:", error);
      }
    }

    // Update the live data display with the most recent gaze values
    function updateLiveData(data) {
      try {
        const now = Date.now();
        if (now - lastUpdate < UPDATE_INTERVAL) return;
        lastUpdate = now;

        const liveDiv = document.getElementById("liveData");
        if (!liveDiv) return;

        // Create a more detailed live data display
        liveDiv.innerHTML = `
          <div class="live-data-grid">
            <div class="data-section">
              <strong>Gaze Data:</strong><br>
              State: <span class="data-value">${data.state || 'N/A'}</span><br>
              X: <span class="data-value">${(data.docX || data.x || 0).toFixed(2)}</span><br>
              Y: <span class="data-value">${(data.docY || data.y || 0).toFixed(2)}</span><br>
              Confidence: <span class="data-value ${(data.confidence || 0) > DATA_QUALITY_THRESHOLD ? 'good' : 'poor'}">${((data.confidence || 0) * 100).toFixed(1)}%</span>
            </div>
            <div class="data-section">
              <strong>Head Position:</strong><br>
              X: <span class="data-value">${(data.HeadX || 0).toFixed(2)}</span><br>
              Y: <span class="data-value">${(data.HeadY || 0).toFixed(2)}</span><br>
              Z: <span class="data-value">${(data.HeadZ || 0).toFixed(2)}</span>
            </div>
            <div class="data-section">
              <strong>Session Info:</strong><br>
              Points: <span class="data-value">${recordedData.length}</span><br>
              Duration: <span class="data-value">${((now - recordedData[0]?.timestamp || now) / 1000).toFixed(1)}s</span><br>
              Status: <span class="data-value ${isCalibrating ? 'calibrating' : (tracking ? 'recording' : 'idle')}">${isCalibrating ? 'Calibrating...' : (tracking ? 'Recording' : 'Idle')}</span>
            </div>
          </div>
        `;
      } catch (error) {
        console.error("Error in updateLiveData:", error);
      }
    }

    // Theme management
    function initializeTheme() {
      const currentTheme = localStorage.getItem('theme') || 'light';
      document.documentElement.setAttribute('data-theme', currentTheme);
      
      const themeToggle = document.createElement('button');
      themeToggle.className = 'theme-toggle';
      themeToggle.innerHTML = currentTheme === 'light' ? 'üåô Dark Mode' : '‚òÄÔ∏è Light Mode';
      themeToggle.onclick = toggleTheme;
      
      document.querySelector('.header').appendChild(themeToggle);
    }
    
    function toggleTheme() {
      const currentTheme = document.documentElement.getAttribute('data-theme');
      const newTheme = currentTheme === 'light' ? 'dark' : 'light';
      
      document.documentElement.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme);
      
      const themeToggle = document.querySelector('.theme-toggle');
      themeToggle.innerHTML = newTheme === 'light' ? 'üåô Dark Mode' : '‚òÄÔ∏è Light Mode';
      
      // Update chart themes if they exist
      updateChartThemes();
    }
    
    function updateChartThemes() {
      const charts = [window.eyeMovementChart, window.pupilDilationChart, window.headMovementChart];
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      
      charts.forEach(chart => {
        if (chart && chart.options) {
          chart.options.scales.x.grid.color = isDark ? '#404040' : '#dddddd';
          chart.options.scales.y.grid.color = isDark ? '#404040' : '#dddddd';
          chart.options.scales.x.ticks.color = isDark ? '#cccccc' : '#666666';
          chart.options.scales.y.ticks.color = isDark ? '#cccccc' : '#666666';
          chart.update();
        }
      });
    }

    // Add the resetDataStructures function before it's used
    function resetDataStructures() {
      try {
        // Clear recorded data array
        recordedData = [];
        
        // Reset state variables
        tracking = false;
        isCalibrating = false;
        lastUpdate = 0;
        lastDataPoint = null;
        
        // Safely destroy existing charts
        const charts = {
          eyeMovementChart: window.eyeMovementChart,
          pupilDilationChart: window.pupilDilationChart,
          headMovementChart: window.headMovementChart
        };
        
        for (const [name, chart] of Object.entries(charts)) {
          if (chart && typeof chart.destroy === 'function') {
            try {
              chart.destroy();
              window[name] = null;
            } catch (chartError) {
              console.error(`Error destroying ${name}:`, chartError);
            }
          }
        }

        // Clear canvas contexts
        ['eyeMovementChart', 'pupilDilationChart', 'headMovementChart'].forEach(canvasId => {
          const canvas = document.getElementById(canvasId);
          if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
          }
        });

        // Reset UI elements
        document.getElementById("liveData").innerHTML = "<em>Live gaze data will appear here...</em>";
        
        // Update UI state
        updateUIState(false);
        
        logMessage("Data structures reset successfully", 'success');
      } catch (error) {
        console.error("Error in resetDataStructures:", error);
        logMessage("Error resetting data structures: " + error.message, 'error');
        throw error; // Re-throw to be caught by the calling function
      }
    }

    // Initialize data collection system
    function initializeDataCollection() {
      try {
        dataCollectionReady = false;
        recordedData = [];
        lastDataPoint = null;
        
        // Configure GazeCloud API settings with proper initialization
        if (typeof GazeCloudAPI === 'undefined') {
          throw new Error("GazeCloud API not loaded");
        }

        // Reset all data structures first
        resetDataStructures();

        // Set required API configuration
        GazeCloudAPI.APIKey = "GazeCloudAPI-Key";
        GazeCloudAPI.CalibrationType = 5; // 5 point calibration
        GazeCloudAPI.ShowVideo = true;
        GazeCloudAPI.UseClickRecalibration = true;

        // Set up all necessary callbacks
        GazeCloudAPI.OnCalibrationComplete = function() {
          isCalibrating = false;
          tracking = true;
          calibrationAttempts = 0;
          logMessage("Calibration completed successfully!", 'success');
          updateUIState(true);
        };

        GazeCloudAPI.OnCalibrationFail = function() {
          handleCalibrationFailure();
        };
        
        GazeCloudAPI.OnCamDenied = function() {
          handleGazeError("Camera access was denied. Please check your camera permissions.");
          updateUIState(false);
        };

        GazeCloudAPI.OnError = function(msg) {
          handleGazeError("GazeCloud API Error: " + msg);
          updateUIState(false);
        };

        GazeCloudAPI.OnResult = function(GazeData) {
          handleGazeData(GazeData);
        };

        // Add initialization callback
        GazeCloudAPI.OnConnect = function() {
          logMessage("GazeCloud API connected successfully", 'success');
          dataCollectionReady = true;
        };

        dataCollectionReady = true;
        logMessage("Data collection system initialized successfully", 'success');
        return true;
      } catch (error) {
        console.error("Error initializing data collection:", error);
        logMessage("Failed to initialize data collection: " + error.message, 'error');
        return false;
      }
    }

    // Handle gaze data processing
    function handleGazeData(GazeData) {
      try {
        if (!tracking || !dataCollectionReady) return;

        const processedData = processGazeData(GazeData);
        if (!processedData) return;

        recordedData.push(processedData);
        if (recordedData.length > MAX_RECORDED_POINTS) {
          recordedData = recordedData.slice(-MAX_RECORDED_POINTS);
          logMessage("Trimming recorded data to prevent memory issues", 'warning');
        }

        updateLiveData(processedData);
        
        if (recordedData.length % 50 === 0) {
          const avgConfidence = mean(recordedData.slice(-50).map(d => d.confidence || 0));
          logMessage(
            `Recording active: ${recordedData.length} points collected | ` +
            `Recent Quality: ${(avgConfidence * 100).toFixed(1)}% | ` +
            `Rate: ${(50000 / (Date.now() - lastUpdate)).toFixed(1)} Hz`,
            avgConfidence > DATA_QUALITY_THRESHOLD ? 'success' : 'warning'
          );
        }
      } catch (error) {
        console.error("Error processing gaze data:", error);
        logMessage("Error processing gaze data: " + error.message, 'error');
      }
    }

    // Handle calibration failure
    function handleCalibrationFailure() {
      isCalibrating = false;
      tracking = false;
      dataCollectionReady = false;
      
      document.getElementById("liveData").innerHTML = `
        <div class="calibration-message error">
          <h3>Calibration Failed</h3>
          <p>Please ensure:</p>
          <ul>
            <li>Your face is well-lit and visible</li>
            <li>You are in a stable position</li>
            <li>Your eyes are clearly visible</li>
            <li>You are looking at the calibration points</li>
          </ul>
          <p>Click "Start Tracking" to try again.</p>
        </div>
      `;
      
      logMessage(`Calibration failed (Attempt ${calibrationAttempts} of ${MAX_CALIBRATION_ATTEMPTS})`, 'error');
      updateUIState(false);
    }

    // Handle GazeCloud API errors
    function handleGazeError(msg) {
      tracking = false;
      isCalibrating = false;
      dataCollectionReady = false;
      logMessage("GazeCloud API Error: " + msg, 'error');
      updateUIState(false);
      
      document.getElementById("liveData").innerHTML = `
        <div class="calibration-message error">
          <h3>Eye Tracking Error</h3>
          <p>${msg}</p>
          <p>Please try again or check your camera settings.</p>
        </div>
      `;
    }

    // Validate and process incoming gaze data
    function processGazeData(gazeData) {
      try {
        if (!gazeData || typeof gazeData !== 'object') return null;
        
        // Validate timestamp and ensure proper interval
        const currentTime = Date.now();
        if (lastDataPoint && (currentTime - lastDataPoint.timestamp) < MIN_DATA_INTERVAL) {
          return null;
        }

        // Process and validate coordinates
        const processedData = {
          timestamp: currentTime,
          x: gazeData.docX !== undefined ? gazeData.docX : gazeData.x,
          y: gazeData.docY !== undefined ? gazeData.docY : gazeData.y,
          state: gazeData.state,
          confidence: gazeData.confidence || 0,
          pupilD: gazeData.pupilD,
          HeadX: gazeData.HeadX,
          HeadY: gazeData.HeadY,
          HeadZ: gazeData.HeadZ,
          HeadYaw: gazeData.HeadYaw,
          HeadPitch: gazeData.HeadPitch,
          HeadRoll: gazeData.HeadRoll
        };

        // Validate data quality
        if (processedData.confidence < DATA_QUALITY_THRESHOLD) {
          logMessage("Low confidence data point detected", 'warning');
          return null;
        }

        lastDataPoint = processedData;
        return processedData;
      } catch (error) {
        console.error("Error processing gaze data:", error);
        logMessage("Error processing gaze data: " + error.message, 'error');
        return null;
      }
    }

    // Start eye tracking with enhanced initialization
    function startTracking() {
      try {
        if (tracking) {
          stopTracking();
          return;
        }

        if (calibrationAttempts >= MAX_CALIBRATION_ATTEMPTS) {
          logMessage(`Too many calibration attempts. Please refresh the page and try again.`, 'error');
          return;
        }

        // Show initialization status
        const liveDataDiv = document.getElementById("liveData");
        liveDataDiv.innerHTML = `
          <div class="calibration-message">
            <h3>Initializing Eye Tracking System</h3>
            <div class="initialization-steps">
              <div class="step" id="step1">
                <span class="step-indicator">‚öôÔ∏è</span>
                <span class="step-text">Loading GazeCloud API...</span>
              </div>
              <div class="step" id="step2">
                <span class="step-indicator">üìä</span>
                <span class="step-text">Configuring tracking parameters...</span>
              </div>
              <div class="step" id="step3">
                <span class="step-indicator">üé•</span>
                <span class="step-text">Preparing camera access...</span>
              </div>
            </div>
            <div class="progress-bar">
              <div class="progress-indicator"></div>
            </div>
          </div>
        `;

        // Wait for DOM to update before proceeding
        setTimeout(() => {
          initializeTracking();
        }, 100);

        function initializeTracking() {
          // Helper function to safely update step status
          function updateStepStatus(stepId, success) {
            try {
              const stepElement = document.querySelector(`#${stepId} .step-text`);
              if (stepElement) {
                stepElement.style.color = success ? 'var(--success-color)' : 'var(--error-color)';
              }
            } catch (error) {
              console.error(`Error updating step ${stepId} status:`, error);
            }
          }

          // Helper function to mark all steps as failed
          function markStepsAsFailed() {
            ['step1', 'step2', 'step3'].forEach(stepId => {
              try {
                updateStepStatus(stepId, false);
              } catch (error) {
                console.error(`Error marking step ${stepId} as failed:`, error);
              }
            });
          }

          // Check GazeCloud API and start initialization
          checkGazeCloudAPI()
            .then(() => {
              updateStepStatus('step1', true);
              return new Promise((resolve, reject) => {
                try {
                  const result = initializeDataCollection();
                  if (result) {
                    resolve(true);
                  } else {
                    reject(new Error("Data collection initialization failed"));
                  }
                } catch (error) {
                  reject(error);
                }
              });
            })
            .then(() => {
              updateStepStatus('step2', true);
              
              return new Promise((resolve, reject) => {
                try {
                  if (!dataCollectionReady) {
                    reject(new Error("Data collection system not ready"));
                    return;
                  }

                  if (typeof GazeCloudAPI === 'undefined' || !GazeCloudAPI.StartEyeTracking) {
                    reject(new Error("GazeCloud API not properly initialized"));
                    return;
                  }

                  updateStepStatus('step3', true);
                  
                  // Start eye tracking with a slight delay to ensure UI is ready
                  setTimeout(() => {
                    try {
                      GazeCloudAPI.StartEyeTracking();
                      isCalibrating = true;
                      calibrationAttempts++;
                      logMessage("Starting eye tracking calibration...", 'info');
                      resolve(true);
                    } catch (error) {
                      reject(error);
                    }
                  }, 200);
                } catch (error) {
                  reject(error);
                }
              });
            })
            .catch((error) => {
              console.error("Error starting tracking:", error);
              markStepsAsFailed();
              logMessage(error.message, 'error');
              handleGazeError("Failed to initialize eye tracking: " + error.message);
            });
        }
      } catch (error) {
        console.error("Error in startTracking:", error);
        tracking = false;
        isCalibrating = false;
        dataCollectionReady = false;
        logMessage("Failed to start tracking: " + error.message, 'error');
        updateUIState(false);
      }
    }

    // Check if GazeCloud API is loaded with improved error handling
    function checkGazeCloudAPI() {
      return new Promise((resolve, reject) => {
        let attempts = 0;
        const maxAttempts = 10;
        const checkInterval = 500; // Check every 500ms for faster response
        
        function check() {
          try {
            if (typeof GazeCloudAPI !== 'undefined' && 
                GazeCloudAPI.StartEyeTracking && 
                typeof GazeCloudAPI.StartEyeTracking === 'function') {
              logMessage("GazeCloud API loaded successfully", 'success');
              resolve(true);
              return;
            }
            
            attempts++;
            if (attempts >= maxAttempts) {
              reject(new Error("GazeCloud API failed to load after multiple attempts"));
              return;
            }
            
            logMessage(`Waiting for GazeCloud API to load (attempt ${attempts}/${maxAttempts})...`, 'info');
            setTimeout(check, checkInterval);
          } catch (error) {
            reject(new Error("Error checking GazeCloud API: " + error.message));
          }
        }
        
        check();
      });
    }

    // Enhanced stop tracking function
    function stopTracking() {
      try {
        // Check if GazeCloud API is available before stopping
        if (typeof GazeCloudAPI !== 'undefined') {
          GazeCloudAPI.StopEyeTracking();
        }
        
        tracking = false;
        isCalibrating = false;
        dataCollectionReady = false;
        
        const message = recordedData.length > 0 
          ? `Stopped eye tracking. Recorded ${recordedData.length} data points.`
          : "Stopped eye tracking. No data was recorded.";
        
        logMessage(message, recordedData.length > 0 ? 'success' : 'warning');
        updateUIState(false);

        // Clear the video elements that GazeCloud API might have created
        const videoElements = document.querySelectorAll('video');
        videoElements.forEach(video => video.remove());

      } catch (error) {
        console.error("Error in stopTracking:", error);
        tracking = false;
        isCalibrating = false;
        dataCollectionReady = false;
        logMessage("Error stopping tracking: " + error.message, 'error');
        updateUIState(false);
      }
    }

    // Export the recorded gaze data as a CSV file
    function exportCSV() {
      try {
        if (recordedData.length === 0) {
          logMessage("No data recorded to export.");
          return;
        }
        let csvContent = "data:text/csv;charset=utf-8,";
        csvContent += "timestamp,x,y,state,confidence,pupilD,HeadX,HeadY,HeadZ,HeadYaw,HeadPitch,HeadRoll\n";
        
        recordedData.forEach(function(data) {
          const timestamp = data.time || data.timestamp || '';
          const x = data.docX !== undefined ? data.docX : data.x || '';
          const y = data.docY !== undefined ? data.docY : data.y || '';
          const state = data.state || '';
          const confidence = data.confidence || '';
          const pupilD = data.pupilD || '';
          const HeadX = data.HeadX || '';
          const HeadY = data.HeadY || '';
          const HeadZ = data.HeadZ || '';
          const HeadYaw = data.HeadYaw || '';
          const HeadPitch = data.HeadPitch || '';
          const HeadRoll = data.HeadRoll || '';
          
          csvContent += `${timestamp},${x},${y},${state},${confidence},${pupilD},${HeadX},${HeadY},${HeadZ},${HeadYaw},${HeadPitch},${HeadRoll}\n`;
        });

        const encodedUri = encodeURI(csvContent);
        const link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", "gaze_data_" + Date.now() + ".csv");
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        logMessage("CSV export completed.");
      } catch (error) {
        console.error("Error in exportCSV:", error);
        logMessage("Failed to export CSV: " + error.message);
      }
    }

    // Clear recorded data and reset the live display
    function clearData() {
      try {
        recordedData = [];
        document.getElementById("liveData").innerHTML = "<em>Live gaze data will appear here...</em>";
        logMessage("Cleared recorded data.");
      } catch (error) {
        console.error("Error in clearData:", error);
      }
    }

    /********** CSV ANALYSIS DASHBOARD SECTION **********/
    // Compute basic statistics from CSV data
    function computeBasicStats(data) {
      try {
        const validConfidence = data.filter(d => d.confidence !== undefined && d.confidence !== null && d.confidence !== '');
        const validPupilData = data.filter(d => d.pupilD !== undefined && d.pupilD !== null && d.pupilD !== '');
        const validHeadData = data.filter(d => 
          d.HeadX !== undefined && d.HeadY !== undefined && d.HeadZ !== undefined &&
          d.HeadX !== null && d.HeadY !== null && d.HeadZ !== null &&
          d.HeadX !== '' && d.HeadY !== '' && d.HeadZ !== ''
        );

        let avgConfidence = validConfidence.length ? (mean(validConfidence.map(d => d.confidence)) * 100).toFixed(1) + '%' : 'N/A';
        let pupilMean = validPupilData.length ? mean(validPupilData.map(d => d.pupilD)).toFixed(2) : 'N/A';
        let pupilMin = validPupilData.length ? Math.min(...validPupilData.map(d => d.pupilD)).toFixed(2) : 'N/A';
        let pupilMax = validPupilData.length ? Math.max(...validPupilData.map(d => d.pupilD)).toFixed(2) : 'N/A';
        let pupilStdDev = validPupilData.length ? standardDeviation(validPupilData.map(d => d.pupilD)).toFixed(2) : 'N/A';

        let headXMean = validHeadData.length ? mean(validHeadData.map(d => d.HeadX)).toFixed(1) : 'N/A';
        let headYMean = validHeadData.length ? mean(validHeadData.map(d => d.HeadY)).toFixed(1) : 'N/A';
        let headZMean = validHeadData.length ? mean(validHeadData.map(d => d.HeadZ)).toFixed(1) : 'N/A';

        const validHeadYaw = data.filter(d => d.HeadYaw !== undefined && d.HeadYaw !== null && d.HeadYaw !== '');
        const validHeadPitch = data.filter(d => d.HeadPitch !== undefined && d.HeadPitch !== null && d.HeadPitch !== '');
        const validHeadRoll = data.filter(d => d.HeadRoll !== undefined && d.HeadRoll !== null && d.HeadRoll !== '');

        let headYawMean = validHeadYaw.length ? mean(validHeadYaw.map(d => d.HeadYaw)).toFixed(1) : 'N/A';
        let headPitchMean = validHeadPitch.length ? mean(validHeadPitch.map(d => d.HeadPitch)).toFixed(1) : 'N/A';
        let headRollMean = validHeadRoll.length ? mean(validHeadRoll.map(d => d.HeadRoll)).toFixed(1) : 'N/A';

        return {
          "Total Data Points": data.length,
          "Valid Data Points": validConfidence.length,
          "Average Confidence": avgConfidence,
          "Pupil Diameter (mm)": {
            "Mean": pupilMean,
            "Min": pupilMin,
            "Max": pupilMax,
            "StdDev": pupilStdDev
          },
          "Head Position": {
            "X Mean": headXMean,
            "Y Mean": headYMean,
            "Z Mean": headZMean
          },
          "Head Rotation (degrees)": {
            "Yaw": headYawMean,
            "Pitch": headPitchMean,
            "Roll": headRollMean
          }
        };
      } catch (error) {
        console.error("Error in computeBasicStats:", error);
        return {};
      }
    }

    // Basic helper functions with error handling
    function mean(arr) {
      try {
        if (!Array.isArray(arr) || !arr.length) return 0;
        return arr.reduce((a, b) => a + b, 0) / arr.length;
      } catch (error) {
        console.error("Error in mean calculation:", error);
        return 0;
      }
    }

    function variance(arr) {
      try {
        if (!Array.isArray(arr) || !arr.length) return 0;
        const m = mean(arr);
        return mean(arr.map(x => (x - m) ** 2));
      } catch (error) {
        console.error("Error in variance calculation:", error);
        return 0;
      }
    }

    function standardDeviation(arr) {
      try {
        return Math.sqrt(variance(arr));
      } catch (error) {
        console.error("Error in standardDeviation calculation:", error);
        return 0;
      }
    }

    // Update the statistics display with error handling
    function updateBasicStats(stats) {
      try {
        const container = document.getElementById('basicStats');
        if (!container) return;
        
        container.innerHTML = '';
        for (const [key, value] of Object.entries(stats)) {
          const card = document.createElement('div');
          card.className = 'stat-card';
          if (typeof value === 'object') {
            let content = `<h3>${key}</h3>`;
            for (const [subKey, subValue] of Object.entries(value)) {
              content += `<p><strong>${subKey}:</strong> ${subValue}</p>`;
            }
            card.innerHTML = content;
          } else {
            card.innerHTML = `<h3>${key}</h3><p>${value}</p>`;
          }
          container.appendChild(card);
        }
      } catch (error) {
        console.error("Error in updateBasicStats:", error);
      }
    }

    // Create visualization charts with error handling
    function createEyeMovementChart(data) {
      try {
        const canvas = document.getElementById('eyeMovementChart');
        if (!canvas) {
          logMessage("Eye movement chart canvas not found", 'error');
          return;
        }

        const ctx = canvas.getContext('2d');
        
        // Safely destroy existing chart
        if (window.eyeMovementChart && typeof window.eyeMovementChart.destroy === 'function') {
          window.eyeMovementChart.destroy();
        }
        window.eyeMovementChart = null;

        const validData = data.filter(d =>
          ((d.x !== undefined && d.x !== '' && d.x !== null) || (d.docX !== undefined && d.docX !== '' && d.docX !== null)) &&
          ((d.y !== undefined && d.y !== '' && d.y !== null) || (d.docY !== undefined && d.docY !== '' && d.docY !== null)) &&
          d.timestamp
        );

        if (!validData.length) {
          logMessage("No valid data for eye movement chart", 'warning');
          return;
        }

        const points = validData.map(d => ({
          x: d.x !== undefined && d.x !== '' ? d.x : d.docX,
          y: d.y !== undefined && d.y !== '' ? d.y : d.docY,
          timestamp: new Date(d.timestamp).getTime()
        }));

        const startTime = points[0].timestamp;
        const endTime = points[points.length - 1].timestamp;

        points.forEach(p => {
          const progress = (p.timestamp - startTime) / (endTime - startTime);
          p.color = `hsl(${200 + progress * 160}, 70%, 50%)`;
        });

        window.eyeMovementChart = new Chart(ctx, {
          type: 'scatter',
          data: {
            datasets: [{
              label: 'Gaze Path',
              data: points,
              backgroundColor: points.map(p => p.color),
              pointRadius: 4,
              pointHoverRadius: 6
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                reverse: true,
                title: { display: true, text: 'Y Position (pixels)' }
              },
              x: {
                title: { display: true, text: 'X Position (pixels)' }
              }
            },
            plugins: {
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const point = context.raw;
                    return [
                      `Position: (${point.x.toFixed(1)}, ${point.y.toFixed(1)})`,
                      `Time: ${new Date(point.timestamp).toLocaleTimeString()}`
                    ];
                  }
                }
              }
            }
          }
        });
      } catch (error) {
        console.error("Error creating eye movement chart:", error);
        logMessage("Failed to create eye movement chart");
      }
    }

    function createPupilDilationChart(data) {
      try {
        const canvas = document.getElementById('pupilDilationChart');
        if (!canvas) {
          logMessage("Pupil dilation chart canvas not found", 'error');
          return;
        }

        const ctx = canvas.getContext('2d');
        
        // Safely destroy existing chart
        if (window.pupilDilationChart && typeof window.pupilDilationChart.destroy === 'function') {
          window.pupilDilationChart.destroy();
        }
        window.pupilDilationChart = null;

        const validData = data.filter(d => d.pupilD !== undefined && d.pupilD !== null && d.pupilD !== '' && d.timestamp);
        
        if (!validData.length) {
          logMessage("No valid data for pupil dilation chart", 'warning');
          return;
        }

        const timestamps = validData.map(d => new Date(d.timestamp));

        window.pupilDilationChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: timestamps,
            datasets: [{
              label: 'Pupil Diameter (mm)',
              data: validData.map(d => ({ x: new Date(d.timestamp), y: d.pupilD })),
              borderColor: 'rgba(75, 192, 192, 1)',
              backgroundColor: 'rgba(75, 192, 192, 0.2)',
              fill: true,
              tension: 0.4
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                type: 'time',
                time: { unit: 'second', displayFormats: { second: 'HH:mm:ss' } },
                title: { display: true, text: 'Time' }
              },
              y: {
                title: { display: true, text: 'Pupil Diameter (mm)' }
              }
            }
          }
        });
      } catch (error) {
        console.error("Error creating pupil dilation chart:", error);
        logMessage("Failed to create pupil dilation chart");
      }
    }

    function createHeadMovementChart(data) {
      try {
        const canvas = document.getElementById('headMovementChart');
        if (!canvas) {
          logMessage("Head movement chart canvas not found", 'error');
          return;
        }

        const ctx = canvas.getContext('2d');
        
        // Safely destroy existing chart
        if (window.headMovementChart && typeof window.headMovementChart.destroy === 'function') {
          window.headMovementChart.destroy();
        }
        window.headMovementChart = null;

        const validData = data.filter(d =>
          d.HeadX !== undefined && d.HeadY !== undefined && d.HeadZ !== undefined &&
          d.HeadX !== null && d.HeadY !== null && d.HeadZ !== null &&
          d.HeadX !== '' && d.HeadY !== '' && d.HeadZ !== '' && d.timestamp
        );

        if (!validData.length) {
          logMessage("No valid data for head movement chart", 'warning');
          return;
        }

        const timestamps = validData.map(d => new Date(d.timestamp));

        window.headMovementChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: timestamps,
            datasets: [
              {
                label: 'Head X',
                data: validData.map(d => ({ x: new Date(d.timestamp), y: d.HeadX })),
                borderColor: 'rgba(255, 99, 132, 1)',
                tension: 0.4
              },
              {
                label: 'Head Y',
                data: validData.map(d => ({ x: new Date(d.timestamp), y: d.HeadY })),
                borderColor: 'rgba(54, 162, 235, 1)',
                tension: 0.4
              },
              {
                label: 'Head Z',
                data: validData.map(d => ({ x: new Date(d.timestamp), y: d.HeadZ })),
                borderColor: 'rgba(75, 192, 192, 1)',
                tension: 0.4
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                type: 'time',
                time: { unit: 'second', displayFormats: { second: 'HH:mm:ss' } },
                title: { display: true, text: 'Time' }
              },
              y: {
                title: { display: true, text: 'Head Position' }
              }
            }
          }
        });
      } catch (error) {
        console.error("Error creating head movement chart:", error);
        logMessage("Failed to create head movement chart");
      }
    }

    // Process uploaded CSV file with enhanced error handling
    function processFile() {
      try {
        const fileInput = document.getElementById('csvFile');
        const file = fileInput.files[0];
        
        if (!file) {
          alert('Please select a CSV file first.');
          return;
        }

        Papa.parse(file, {
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true,
          complete: function(results) {
            try {
              if (results.errors.length > 0) {
                console.error('CSV parsing errors:', results.errors);
                alert('Error parsing CSV file. Please check the console for details.');
                return;
              }

              const data = results.data.filter(row => row.timestamp != null && row.timestamp !== '');
              
              if (data.length === 0) {
                alert('No valid data found in the CSV file.');
                return;
              }

              const stats = computeBasicStats(data);
              updateBasicStats(stats);
              createEyeMovementChart(data);
              createPupilDilationChart(data);
              createHeadMovementChart(data);
              
              logMessage(`Successfully processed ${data.length} data points`);
            } catch (error) {
              console.error("Error in Papa.parse complete callback:", error);
              alert('Error processing CSV data: ' + error.message);
            }
          },
          error: function(error) {
            console.error('Error parsing CSV:', error);
            alert('Failed to parse CSV file: ' + error.message);
          }
        });
      } catch (error) {
        console.error("Error in processFile:", error);
        alert('Error processing file: ' + error.message);
      }
    }

    // Add window error handler for uncaught errors
    window.onerror = function(message, source, lineno, colno, error) {
      console.error("Global error:", {message, source, lineno, colno, error});
      logMessage(`Uncaught error: ${message}`);
      return false;
    };

    // Add chart toggle functionality
    function toggleChart(chartId) {
      // Hide all charts
      document.querySelectorAll('.chart-container').forEach(container => {
        container.classList.remove('active');
      });
      
      // Deactivate all toggle buttons
      document.querySelectorAll('.chart-toggle').forEach(button => {
        button.classList.remove('active');
      });
      
      // Show selected chart and activate its toggle
      document.getElementById(chartId + 'Container').classList.add('active');
      document.getElementById(chartId + 'Toggle').classList.add('active');
    }
    
    // Initialize with eye movement chart visible and theme
    window.addEventListener('load', function() {
      toggleChart('eyeMovement');
      initializeTheme();
    });

    // Add window focus/blur handlers
    window.addEventListener('blur', function() {
      if (tracking) {
        logMessage("Window lost focus. Consider recalibrating if tracking accuracy decreases.", 'warning');
      }
    });

    // Add connection status check
    window.addEventListener('online', function() {
      logMessage("Internet connection restored.", 'success');
    });

    window.addEventListener('offline', function() {
      logMessage("Internet connection lost. Tracking may be affected.", 'error');
      if (tracking) {
        stopTracking();
      }
    });

    // Add beforeunload handler
    window.addEventListener('beforeunload', function(e) {
      if (tracking || recordedData.length > 0) {
        const message = "You have active tracking or unsaved data. Are you sure you want to leave?";
        e.returnValue = message;
        return message;
      }
    });
  </script>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Eye Tracking Recorder & Analysis Dashboard</h1>
      <!-- Theme toggle will be inserted here by JavaScript -->
    </div>
    
    <!-- LIVE TRACKING SECTION -->
    <section id="liveTrackingSection">
      <h2>Live Eye Tracking Recorder</h2>
      <div id="liveControls">
        <button type="button" onclick="startTracking()">Start Tracking</button>
        <button type="button" onclick="stopTracking()">Stop Tracking</button>
        <button type="button" onclick="exportCSV()">Export CSV</button>
        <button type="button" onclick="clearData()">Clear Data</button>
      </div>
      <div id="liveData">
        <em>Live gaze data will appear here...</em>
      </div>
      <div id="debugLog">
        <em>Debug log messages will appear here...</em>
      </div>
    </section>

    <hr>

    <!-- CSV ANALYSIS DASHBOARD SECTION -->
    <section id="analysisDashboardSection">
      <h2>CSV Data Analysis Dashboard</h2>
      <div class="file-input">
        <label for="csvFile">Select CSV File:</label>
        <input type="file" id="csvFile" accept=".csv" title="Upload gaze tracking data CSV file">
        <button type="button" onclick="processFile()">Analyze Data</button>
      </div>
      <div class="stats-container" id="basicStats"></div>
      <div class="chart-controls">
        <button type="button" id="eyeMovementToggle" class="chart-toggle red active" onclick="toggleChart('eyeMovement')">Eye Movement</button>
        <button type="button" id="pupilDilationToggle" class="chart-toggle green" onclick="toggleChart('pupilDilation')">Pupil Dilation</button>
        <button type="button" id="headMovementToggle" class="chart-toggle blue" onclick="toggleChart('headMovement')">Head Movement</button>
      </div>
      <div id="eyeMovementContainer" class="chart-container active">
        <h3>Eye Movement Trajectory</h3>
        <canvas id="eyeMovementChart"></canvas>
      </div>
      <div id="pupilDilationContainer" class="chart-container">
        <h3>Pupil Dilation Over Time</h3>
        <canvas id="pupilDilationChart"></canvas>
      </div>
      <div id="headMovementContainer" class="chart-container">
        <h3>Head Displacement Over Time</h3>
        <canvas id="headMovementChart"></canvas>
      </div>
    </section>
  </div>
</body>
</html>
