<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Eye Tracking Recorder & Analysis Dashboard</title>
  <!-- GazeCloudAPI for live tracking -->
  <script src="https://api.gazerecorder.com/GazeCloudAPI.js"></script>
  <!-- Chart.js for visualizations -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
  <!-- PapaParse for CSV processing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
  <style>
    :root {
      /* Light theme variables */
      --bg-primary: #f5f5f5;
      --bg-secondary: #ffffff;
      --text-primary: #333333;
      --text-secondary: #666666;
      --border-color: #dddddd;
      --shadow-color: rgba(0, 0, 0, 0.1);
      --accent-color: #4a90e2;
      --success-color: #2ecc71;
      --warning-color: #f1c40f;
      --error-color: #e74c3c;
      --chart-bg: rgba(255, 255, 255, 0.9);
      --notification-bg: rgba(255, 255, 255, 0.95);
    }

    [data-theme="dark"] {
      /* Dark theme variables */
      --bg-primary: #1a1a1a;
      --bg-secondary: #2d2d2d;
      --text-primary: #ffffff;
      --text-secondary: #cccccc;
      --border-color: #404040;
      --shadow-color: rgba(0, 0, 0, 0.3);
      --accent-color: #64b5f6;
      --success-color: #66bb6a;
      --warning-color: #ffd54f;
      --error-color: #ef5350;
      --chart-bg: rgba(45, 45, 45, 0.9);
      --notification-bg: rgba(45, 45, 45, 0.95);
    }

    /* Theme transition */
    * {
      transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
    }

    body {
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--bg-primary);
      color: var(--text-primary);
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
    }

    .theme-toggle {
      background: var(--bg-secondary);
      border: 2px solid var(--border-color);
      border-radius: 20px;
      padding: 5px 15px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.9em;
      color: var(--text-primary);
      transition: transform 0.2s ease;
    }

    .theme-toggle:hover {
      transform: scale(1.05);
    }

    .theme-toggle:active {
      transform: scale(0.95);
    }

    h1, h2, h3 {
      color: var(--text-primary);
      margin: 0;
    }

    hr {
      margin: 40px 0;
      border: none;
      border-top: 1px solid var(--border-color);
    }

    button {
      background: var(--bg-secondary);
      color: var(--text-primary);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      padding: 10px 20px;
      font-size: 1em;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    button:hover {
      background: var(--accent-color);
      color: white;
      border-color: var(--accent-color);
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    #liveData, #debugLog {
      background-color: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
      box-shadow: 0 2px 8px var(--shadow-color);
    }

    #liveData {
      min-height: 50px;
    }

    #debugLog {
      max-height: 200px;
      overflow-y: auto;
      font-family: 'Consolas', monospace;
      font-size: 0.9em;
      white-space: pre-wrap;
    }

    .file-input, .stats-container, .chart-container {
      background: var(--bg-secondary);
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 12px var(--shadow-color);
      margin-bottom: 30px;
      border: 1px solid var(--border-color);
    }

    .stats-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
    }

    .stat-card {
      background: var(--bg-secondary);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 6px var(--shadow-color);
      border: 1px solid var(--border-color);
    }

    .chart-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      justify-content: center;
    }

    .chart-toggle {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      opacity: 0.7;
    }

    .chart-toggle.active {
      opacity: 1;
      transform: scale(1.05);
      box-shadow: 0 4px 12px var(--shadow-color);
    }

    /* Notification system */
    .notification-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }

    .notification {
      background: var(--notification-bg);
      color: var(--text-primary);
      padding: 15px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px var(--shadow-color);
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      pointer-events: auto;
      animation: slideIn 0.3s ease forwards;
      max-width: 300px;
      border-left: 4px solid var(--accent-color);
    }

    .notification.success { border-color: var(--success-color); }
    .notification.warning { border-color: var(--warning-color); }
    .notification.error { border-color: var(--error-color); }

    .notification.fade-out {
      animation: slideOut 0.3s ease forwards;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* Chart theme adaptations */
    .chart-container {
      background: var(--chart-bg);
    }

    canvas {
      border-radius: 8px;
    }

    .live-data-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      padding: 15px;
      background: var(--bg-secondary);
      border-radius: 8px;
      box-shadow: 0 2px 8px var(--shadow-color);
    }
    
    .data-section {
      padding: 10px;
      border-left: 3px solid var(--accent-color);
    }
    
    .data-value {
      font-family: 'Consolas', monospace;
      font-weight: 600;
      color: var(--text-primary);
    }
    
    .data-value.good { color: var(--success-color); }
    .data-value.poor { color: var(--error-color); }
    .data-value.calibrating { color: var(--warning-color); }
    .data-value.recording { color: var(--success-color); }
    .data-value.idle { color: var(--text-secondary); }
    
    #liveData {
      margin: 20px 0;
      transition: all 0.3s ease;
    }

    .calibration-message {
      background: var(--bg-secondary);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px var(--shadow-color);
      margin: 20px 0;
      border-left: 4px solid var(--accent-color);
    }
    
    .calibration-message.error {
      border-left-color: var(--error-color);
    }
    
    .calibration-message h3 {
      margin: 0 0 15px 0;
      color: var(--text-primary);
    }
    
    .calibration-message ol,
    .calibration-message ul {
      margin: 10px 0;
      padding-left: 25px;
    }
    
    .calibration-message li {
      margin: 8px 0;
      color: var(--text-secondary);
    }

    .initialization-steps {
      margin: 15px 0;
    }
    
    .step {
      display: flex;
      align-items: center;
      margin: 10px 0;
      gap: 10px;
    }
    
    .step-indicator {
      font-size: 1.2em;
    }
    
    .calibration-progress {
      margin: 20px 0;
    }
    
    .progress-bar {
      height: 6px;
      background: var(--border-color);
      border-radius: 3px;
      overflow: hidden;
    }
    
    .progress-indicator {
      height: 100%;
      background: var(--accent-color);
      width: 0%;
      animation: progress 30s linear;
    }
    
    @keyframes progress {
      from { width: 0%; }
      to { width: 100%; }
    }
    
    .calibration-message ol li {
      opacity: 0.6;
      transition: opacity 0.3s ease;
    }
    
    .calibration-message ol li.active {
      opacity: 1;
      color: var(--text-primary);
      font-weight: 600;
    }

    .sessions-container {
      background: var(--bg-secondary);
      padding: 20px;
      border-radius: 12px;
      margin: 20px 0;
      box-shadow: 0 4px 12px var(--shadow-color);
    }

    .session-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      margin: 10px 0;
      background: var(--bg-primary);
      border-radius: 8px;
      border: 1px solid var(--border-color);
    }

    .session-info {
      display: flex;
      gap: 20px;
      align-items: center;
    }

    .session-actions {
      display: flex;
      gap: 10px;
    }

    .session-actions button {
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
    }
  </style>
  <script>
    /********** LIVE EYE TRACKING SECTION **********/
    let recordedData = [];
    let tracking = false;
    let lastUpdate = 0;
    let calibrationAttempts = 0;
    let isCalibrating = false;
    let dataCollectionReady = false;
    let lastDataPoint = null;
    const UPDATE_INTERVAL = 50; // ms
    const MAX_RECORDED_POINTS = 10000;
    const MAX_CALIBRATION_ATTEMPTS = 3;
    const CALIBRATION_TIMEOUT = 30000; // 30 seconds
    const MIN_DATA_INTERVAL = 16; // Minimum interval between data points (ms)
    const DATA_QUALITY_THRESHOLD = 0.6; // Minimum confidence threshold

    // Add database handling code after the existing variables
    const DB_NAME = 'EyeTrackingDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'sessions';
    let db;

    // Initialize database
    function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onerror = (event) => {
          logMessage("Database error: " + event.target.error, 'error');
          reject(event.target.error);
        };
        
        request.onsuccess = (event) => {
          db = event.target.result;
          logMessage("Database initialized successfully", 'success');
          resolve(db);
        };
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            const store = db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
            store.createIndex('timestamp', 'timestamp', { unique: false });
            store.createIndex('duration', 'duration', { unique: false });
            logMessage("Database structure created", 'info');
          }
        };
      });
    }

    // Save session data to database
    function saveSessionToDB(sessionData) {
      return new Promise((resolve, reject) => {
        if (!db) {
          reject(new Error("Database not initialized"));
          return;
        }

        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        
        const session = {
          timestamp: new Date().toISOString(),
          duration: sessionData.length > 0 ? 
            (sessionData[sessionData.length - 1].timestamp - sessionData[0].timestamp) / 1000 : 0,
          dataPoints: sessionData.length,
          averageConfidence: mean(sessionData.map(d => d.confidence || 0)),
          data: sessionData
        };

        const request = store.add(session);
        
        request.onsuccess = () => {
          logMessage(`Session saved to database (${session.dataPoints} points)`, 'success');
          resolve(request.result);
        };
        
        request.onerror = () => {
          logMessage("Error saving session to database", 'error');
          reject(request.error);
        };
      });
    }

    // Load sessions from database
    function loadSessions() {
      return new Promise((resolve, reject) => {
        if (!db) {
          reject(new Error("Database not initialized"));
          return;
        }

        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.getAll();

        request.onsuccess = () => {
          const sessions = request.result;
          updateSessionsList(sessions);
          resolve(sessions);
        };

        request.onerror = () => {
          logMessage("Error loading sessions from database", 'error');
          reject(request.error);
        };
      });
    }

    // Update sessions list in UI
    function updateSessionsList(sessions) {
      const sessionsList = document.getElementById('sessionsList');
      if (!sessionsList) return;

      sessionsList.innerHTML = '';
      sessions.forEach(session => {
        const sessionElement = document.createElement('div');
        sessionElement.className = 'session-item';
        sessionElement.innerHTML = `
          <div class="session-info">
            <strong>Session ${session.id}</strong>
            <span>Date: ${new Date(session.timestamp).toLocaleString()}</span>
            <span>Duration: ${session.duration.toFixed(1)}s</span>
            <span>Points: ${session.dataPoints}</span>
            <span>Confidence: ${(session.averageConfidence * 100).toFixed(1)}%</span>
          </div>
          <div class="session-actions">
            <button onclick="loadSessionData(${session.id})">View</button>
            <button onclick="exportSessionData(${session.id})">Export</button>
            <button onclick="deleteSession(${session.id})">Delete</button>
          </div>
        `;
        sessionsList.appendChild(sessionElement);
      });
    }

    // Load specific session data
    function loadSessionData(sessionId) {
      const transaction = db.transaction([STORE_NAME], 'readonly');
      const store = transaction.objectStore(STORE_NAME);
      const request = store.get(sessionId);

      request.onsuccess = () => {
        const session = request.result;
        if (session) {
          // Update charts with session data
          createEyeMovementChart(session.data);
          createPupilDilationChart(session.data);
          createHeadMovementChart(session.data);
          // Update stats
          const stats = computeBasicStats(session.data);
          updateBasicStats(stats);
          logMessage(`Loaded session ${sessionId} data`, 'success');
        }
      };

      request.onerror = () => {
        logMessage(`Error loading session ${sessionId}`, 'error');
      };
    }

    // Export specific session data
    function exportSessionData(sessionId) {
      const transaction = db.transaction([STORE_NAME], 'readonly');
      const store = transaction.objectStore(STORE_NAME);
      const request = store.get(sessionId);

      request.onsuccess = () => {
        const session = request.result;
        if (session) {
          const csvContent = "data:text/csv;charset=utf-8,";
          // Add headers
          csvContent += "timestamp,x,y,state,confidence,pupilD,HeadX,HeadY,HeadZ,HeadYaw,HeadPitch,HeadRoll\n";
          
          // Add data rows
          session.data.forEach(data => {
            const row = [
              data.timestamp,
              data.x || '',
              data.y || '',
              data.state || '',
              data.confidence || '',
              data.pupilD || '',
              data.HeadX || '',
              data.HeadY || '',
              data.HeadZ || '',
              data.HeadYaw || '',
              data.HeadPitch || '',
              data.HeadRoll || ''
            ].join(',');
            csvContent += row + "\n";
          });

          const encodedUri = encodeURI(csvContent);
          const link = document.createElement("a");
          link.setAttribute("href", encodedUri);
          link.setAttribute("download", `eye_tracking_session_${sessionId}_${new Date().toISOString()}.csv`);
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          logMessage(`Exported session ${sessionId} data`, 'success');
        }
      };

      request.onerror = () => {
        logMessage(`Error exporting session ${sessionId}`, 'error');
      };
    }

    // Delete specific session
    function deleteSession(sessionId) {
      if (!confirm('Are you sure you want to delete this session?')) return;

      const transaction = db.transaction([STORE_NAME], 'readwrite');
      const store = transaction.objectStore(STORE_NAME);
      const request = store.delete(sessionId);

      request.onsuccess = () => {
        logMessage(`Deleted session ${sessionId}`, 'success');
        loadSessions(); // Refresh the sessions list
      };

      request.onerror = () => {
        logMessage(`Error deleting session ${sessionId}`, 'error');
      };
    }

    // Update UI state
    function updateUIState(isRecording) {
      try {
        const startBtn = document.querySelector('button[onclick="startTracking()"]');
        const stopBtn = document.querySelector('button[onclick="stopTracking()"]');
        const exportBtn = document.querySelector('button[onclick="exportCSV()"]');
        const clearBtn = document.querySelector('button[onclick="clearData()"]');
        
        if (startBtn) startBtn.disabled = isRecording;
        if (stopBtn) stopBtn.disabled = !isRecording;
        if (exportBtn) exportBtn.disabled = !recordedData.length;
        if (clearBtn) clearBtn.disabled = !recordedData.length;
      } catch (error) {
        console.error("Error updating UI state:", error);
      }
    }

    // Enhanced logging with severity levels
    function logMessage(message, level = 'info') {
      try {
        const logDiv = document.getElementById("debugLog");
        const timestamp = new Date().toLocaleTimeString();
        const logLevels = {
          error: '🔴',
          warning: '🟡',
          success: '🟢',
          info: 'ℹ️'
        };
        const logEntry = `[${timestamp}] ${logLevels[level] || 'ℹ️'} ${message}\n`;
        
        logDiv.textContent += logEntry;
        logDiv.scrollTop = logDiv.scrollHeight;
        
        // Console logging with appropriate methods
        switch(level) {
          case 'error':
            console.error(message);
            break;
          case 'warning':
            console.warn(message);
            break;
          default:
            console.log(message);
        }
      } catch (error) {
        console.error("Error in logMessage:", error);
      }
    }

    // Update the live data display with the most recent gaze values
    function updateLiveData(data) {
      try {
        const now = Date.now();
        if (now - lastUpdate < UPDATE_INTERVAL) return;
        lastUpdate = now;

        const liveDiv = document.getElementById("liveData");
        if (!liveDiv) return;

        // Create a more detailed live data display
        liveDiv.innerHTML = `
          <div class="live-data-grid">
            <div class="data-section">
              <strong>Gaze Data:</strong><br>
              State: <span class="data-value">${data.state || 'N/A'}</span><br>
              X: <span class="data-value">${(data.docX || data.x || 0).toFixed(2)}</span><br>
              Y: <span class="data-value">${(data.docY || data.y || 0).toFixed(2)}</span><br>
              Confidence: <span class="data-value ${(data.confidence || 0) > DATA_QUALITY_THRESHOLD ? 'good' : 'poor'}">${((data.confidence || 0) * 100).toFixed(1)}%</span>
            </div>
            <div class="data-section">
              <strong>Head Position:</strong><br>
              X: <span class="data-value">${(data.HeadX || 0).toFixed(2)}</span><br>
              Y: <span class="data-value">${(data.HeadY || 0).toFixed(2)}</span><br>
              Z: <span class="data-value">${(data.HeadZ || 0).toFixed(2)}</span>
            </div>
            <div class="data-section">
              <strong>Session Info:</strong><br>
              Points: <span class="data-value">${recordedData.length}</span><br>
              Duration: <span class="data-value">${((now - recordedData[0]?.timestamp || now) / 1000).toFixed(1)}s</span><br>
              Status: <span class="data-value ${isCalibrating ? 'calibrating' : (tracking ? 'recording' : 'idle')}">${isCalibrating ? 'Calibrating...' : (tracking ? 'Recording' : 'Idle')}</span>
            </div>
          </div>
        `;
      } catch (error) {
        console.error("Error in updateLiveData:", error);
      }
    }

    // Theme management
    function initializeTheme() {
      const currentTheme = localStorage.getItem('theme') || 'light';
      document.documentElement.setAttribute('data-theme', currentTheme);
      
      const themeToggle = document.createElement('button');
      themeToggle.className = 'theme-toggle';
      themeToggle.innerHTML = currentTheme === 'light' ? '🌙 Dark Mode' : '☀️ Light Mode';
      themeToggle.onclick = toggleTheme;
      
      document.querySelector('.header').appendChild(themeToggle);
    }
    
    function toggleTheme() {
      const currentTheme = document.documentElement.getAttribute('data-theme');
      const newTheme = currentTheme === 'light' ? 'dark' : 'light';
      
      document.documentElement.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme);
      
      const themeToggle = document.querySelector('.theme-toggle');
      themeToggle.innerHTML = newTheme === 'light' ? '🌙 Dark Mode' : '☀️ Light Mode';
      
      // Update chart themes if they exist
      updateChartThemes();
    }
    
    function updateChartThemes() {
      const charts = [window.eyeMovementChart, window.pupilDilationChart, window.headMovementChart];
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      
      charts.forEach(chart => {
        if (chart && chart.options) {
          chart.options.scales.x.grid.color = isDark ? '#404040' : '#dddddd';
          chart.options.scales.y.grid.color = isDark ? '#404040' : '#dddddd';
          chart.options.scales.x.ticks.color = isDark ? '#cccccc' : '#666666';
          chart.options.scales.y.ticks.color = isDark ? '#cccccc' : '#666666';
          chart.update();
        }
      });
    }

    // Add the resetDataStructures function before it's used
    function resetDataStructures() {
      try {
        // Clear recorded data array
        recordedData = [];
        
        // Reset state variables
        tracking = false;
        isCalibrating = false;
        lastUpdate = 0;
        lastDataPoint = null;
        
        // Safely destroy existing charts
        const charts = {
          eyeMovementChart: window.eyeMovementChart,
          pupilDilationChart: window.pupilDilationChart,
          headMovementChart: window.headMovementChart
        };
        
        for (const [name, chart] of Object.entries(charts)) {
          if (chart && typeof chart.destroy === 'function') {
            try {
              chart.destroy();
              window[name] = null;
            } catch (chartError) {
              console.error(`Error destroying ${name}:`, chartError);
            }
          }
        }

        // Clear canvas contexts
        ['eyeMovementChart', 'pupilDilationChart', 'headMovementChart'].forEach(canvasId => {
          const canvas = document.getElementById(canvasId);
          if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
          }
        });

        // Reset UI elements
        document.getElementById("liveData").innerHTML = "<em>Live gaze data will appear here...</em>";
        
        // Update UI state
        updateUIState(false);
        
        logMessage("Data structures reset successfully", 'success');
      } catch (error) {
        console.error("Error in resetDataStructures:", error);
        logMessage("Error resetting data structures: " + error.message, 'error');
        throw error; // Re-throw to be caught by the calling function
      }
    }

    // Add API verification states
    const API_STATES = {
      INITIALIZING: 'initializing',
      CONNECTING: 'connecting',
      CONNECTED: 'connected',
      CALIBRATING: 'calibrating',
      RECORDING: 'recording',
      ERROR: 'error'
    };
    let apiState = API_STATES.INITIALIZING;
    let calibrationStartTime = 0;

    // Add debug mode and detailed error tracking
    const DEBUG = true;
    const ERROR_CODES = {
      API_NOT_FOUND: 'API_NOT_FOUND',
      API_LOAD_TIMEOUT: 'API_LOAD_TIMEOUT',
      WEBSOCKET_ERROR: 'WEBSOCKET_ERROR',
      CAMERA_DENIED: 'CAMERA_DENIED',
      INITIALIZATION_ERROR: 'INITIALIZATION_ERROR',
      CALIBRATION_ERROR: 'CALIBRATION_ERROR',
      CONNECTION_ERROR: 'CONNECTION_ERROR'
    };

    // Enhanced error logging
    function debugLog(message, data = null) {
      if (!DEBUG) return;
      const timestamp = new Date().toISOString();
      console.log(`[${timestamp}] Debug:`, message);
      if (data) console.log('Debug data:', data);
      logMessage(`🔍 Debug: ${message}`, 'info');
    }

    // Enhanced API verification with detailed checks
    function verifyGazeCloudAPI() {
      return new Promise((resolve, reject) => {
        debugLog('Starting GazeCloud API verification');
        
        // Check if script is loaded
        const gazeScript = document.querySelector('script[src*="GazeCloudAPI.js"]');
        if (!gazeScript) {
          debugLog('GazeCloud API script tag not found');
          reject({ code: ERROR_CODES.API_NOT_FOUND, message: 'GazeCloud API script not found in DOM' });
          return;
        }

        // Verify API object
        if (typeof GazeCloudAPI === 'undefined') {
          debugLog('GazeCloud API object not defined');
          reject({ code: ERROR_CODES.API_NOT_FOUND, message: 'GazeCloud API not found. Please check your internet connection.' });
          return;
        }

        // Verify required methods with detailed logging
        const requiredMethods = [
          'StartEyeTracking',
          'StopEyeTracking',
          'OnResult',
          'OnCalibrationComplete',
          'OnCalibrationFail',
          'OnCamDenied',
          'OnError'
        ];

        const missingMethods = requiredMethods.filter(method => {
          const exists = typeof GazeCloudAPI[method] === 'function';
          debugLog(`Checking method ${method}: ${exists ? 'Found' : 'Missing'}`);
          return !exists;
        });
        
        if (missingMethods.length > 0) {
          reject({
            code: ERROR_CODES.INITIALIZATION_ERROR,
            message: `Missing required GazeCloud API methods: ${missingMethods.join(', ')}`
          });
          return;
        }

        // Verify WebSocket support
        if (!window.WebSocket) {
          reject({
            code: ERROR_CODES.WEBSOCKET_ERROR,
            message: 'WebSocket support not available in browser'
          });
          return;
        }

        debugLog('API verification completed successfully');
        resolve(true);
      });
    }

    // Enhanced initialization with better error handling
    function initializeDataCollection() {
      debugLog('Starting data collection initialization');
      
      try {
        dataCollectionReady = false;
        recordedData = [];
        lastDataPoint = null;
        apiState = API_STATES.INITIALIZING;
        
        return verifyGazeCloudAPI()
          .then(() => {
            debugLog('API verified, resetting data structures');
            resetDataStructures();

            debugLog('Configuring GazeCloud API settings');
            
            // Configure with validation
            const config = {
              CalibrationType: 5, // 5-point calibration
              ShowVideo: true,
              UseClickRecalibration: true,
              Debug: DEBUG,
              GazeFlowContainer: 'liveData', // Specify container for calibration UI
              VideoElementContainer: 'liveData', // Specify container for video feed
              CallbackTrackingReady: function() {
                debugLog('Tracking ready callback triggered');
                logMessage("✅ Eye tracking system ready", 'success');
              },
              CallbackCalibrationFailed: function(error) {
                debugLog('Calibration failed callback', error);
                handleCalibrationFailure();
              }
            };

            Object.entries(config).forEach(([key, value]) => {
              try {
                GazeCloudAPI[key] = value;
                debugLog(`Set ${key} = ${value}`);
              } catch (error) {
                debugLog(`Error setting ${key}`, error);
              }
            });

            // Enhanced callback setup with debugging
            GazeCloudAPI.OnCalibrationComplete = function() {
              debugLog('Calibration completed');
              apiState = API_STATES.RECORDING;
              isCalibrating = false;
              tracking = true;
              calibrationAttempts = 0;
              logMessage("✅ Calibration completed successfully!", 'success');
              updateCalibrationUI('complete');
              updateUIState(true);
            };

            GazeCloudAPI.OnCalibrationFail = function() {
              debugLog('Calibration failed');
              apiState = API_STATES.ERROR;
              handleCalibrationFailure();
            };

            GazeCloudAPI.OnCamDenied = function() {
              debugLog('Camera access denied');
              apiState = API_STATES.ERROR;
              handleGazeError({
                code: ERROR_CODES.CAMERA_DENIED,
                message: "❌ Camera access denied. Please check your camera permissions."
              });
              updateUIState(false);
            };

            GazeCloudAPI.OnError = function(msg) {
              debugLog('GazeCloud API error', msg);
              apiState = API_STATES.ERROR;
              if (msg.includes("connection lost") || msg.includes("WebSocket") || msg.includes("network")) {
                handleConnectionLost();
              } else {
                handleGazeError({
                  code: ERROR_CODES.API_LOAD_TIMEOUT,
                  message: "GazeCloud API Error: " + msg
                });
              }
              updateUIState(false);
            };

            GazeCloudAPI.OnConnect = function() {
              debugLog('GazeCloud API connected');
              apiState = API_STATES.CONNECTED;
              logMessage("✅ GazeCloud API connected successfully", 'success');
              updateConnectionUI('connected');
              dataCollectionReady = true;
            };

            GazeCloudAPI.OnResult = function(GazeData) {
              if (apiState === API_STATES.RECORDING) {
                handleGazeData(GazeData);
              }
            };

            GazeCloudAPI.OnCalibrationStart = function() {
              debugLog('Calibration started');
              apiState = API_STATES.CALIBRATING;
              calibrationStartTime = Date.now();
              isCalibrating = true;
              logMessage("🎯 Starting calibration process...", 'info');
              updateCalibrationUI('start');
            };

            debugLog('Data collection system initialized');
            dataCollectionReady = true;
            logMessage("✅ Data collection system initialized successfully", 'success');
            return true;
          })
          .catch(error => {
            debugLog('Initialization failed', error);
            logMessage(`❌ API Initialization failed: ${error.message}`, 'error');
            return false;
          });
      } catch (error) {
        debugLog('Fatal initialization error', error);
        console.error("Error initializing data collection:", error);
        logMessage("❌ Failed to initialize data collection: " + error.message, 'error');
        return false;
      }
    }

    // Update UI based on calibration state
    function updateCalibrationUI(state) {
      const liveData = document.getElementById("liveData");
      switch(state) {
        case 'start':
          liveData.innerHTML = `
            <div class="calibration-message">
              <h3>🎯 Calibration in Progress</h3>
              <p>Please follow these steps:</p>
              <ol>
                <li class="active">Look at each calibration point as it appears</li>
                <li>Keep your head still during calibration</li>
                <li>Follow the point with your eyes only</li>
                <li>Wait for all points to be completed</li>
              </ol>
              <div class="calibration-progress">
                <div class="progress-bar">
                  <div class="progress-indicator"></div>
                </div>
              </div>
            </div>
          `;
          break;
        case 'complete':
          liveData.innerHTML = `
            <div class="calibration-message success">
              <h3>✅ Calibration Complete</h3>
              <p>Eye tracking is now active and recording data.</p>
              <div class="live-data-grid">
                <div class="data-section">
                  <strong>Status:</strong>
                  <span class="data-value recording">Recording</span>
                </div>
              </div>
            </div>
          `;
          break;
      }
    }

    // Update UI based on connection state
    function updateConnectionUI(state) {
      const liveData = document.getElementById("liveData");
      switch(state) {
        case 'connecting':
          liveData.innerHTML = `
            <div class="calibration-message">
              <h3>🔄 Connecting to GazeCloud</h3>
              <div class="initialization-steps">
                <div class="step">
                  <span class="step-indicator">⚙️</span>
                  <span class="step-text">Establishing connection...</span>
                </div>
              </div>
              <div class="progress-bar">
                <div class="progress-indicator"></div>
              </div>
            </div>
          `;
          break;
        case 'connected':
          liveData.innerHTML = `
            <div class="calibration-message success">
              <h3>✅ Connected Successfully</h3>
              <p>Preparing for calibration...</p>
            </div>
          `;
          break;
      }
    }

    // Enhanced check for GazeCloud API with connection validation
    function checkGazeCloudAPI() {
      return new Promise((resolve, reject) => {
        let attempts = 0;
        const maxAttempts = 20; // Increased max attempts
        const checkInterval = 1000; // Increased interval to 1 second
        
        function check() {
          debugLog(`Checking GazeCloud API (attempt ${attempts + 1}/${maxAttempts})`);
          
          try {
            // First check if script is loaded
            const gazeScript = document.querySelector('script[src*="GazeCloudAPI.js"]');
            if (!gazeScript) {
              // If script is not found, inject it
              const script = document.createElement('script');
              script.src = 'https://api.gazerecorder.com/GazeCloudAPI.js';
              script.async = true;
              document.head.appendChild(script);
              debugLog('Injected GazeCloud API script');
            }

            if (typeof GazeCloudAPI !== 'undefined' && 
                GazeCloudAPI.StartEyeTracking && 
                typeof GazeCloudAPI.StartEyeTracking === 'function') {
              
              // Additional connection validation
              if (window.WebSocket) {
                apiState = API_STATES.CONNECTED;
                logMessage("✅ GazeCloud API loaded successfully", 'success');
                resolve(true);
                return;
              } else {
                reject(new Error("❌ WebSocket support not available"));
                return;
              }
            }
            
            attempts++;
            if (attempts >= maxAttempts) {
              reject(new Error("❌ GazeCloud API failed to load after multiple attempts"));
              return;
            }
            
            logMessage(`⏳ Waiting for GazeCloud API to load (attempt ${attempts}/${maxAttempts})...`, 'info');
            setTimeout(check, checkInterval);
          } catch (error) {
            reject(new Error("❌ Error checking GazeCloud API: " + error.message));
          }
        }
        
        check();
      });
    }

    // Add DataStorageService class definition
    class DataStorageService {
      constructor() {
        this.currentSession = {
          config: null,
          gazeData: []
        };
        this.sessionStartTime = 0;
        this.lastFixationStart = 0;
        this.lastGazePoint = null;
        this.fixationCount = 0;
        this.totalFixationDuration = 0;
        this.saccadeCount = 0;
        this.totalSaccadeLength = 0;
        this.blinkCount = 0;
        this.lastBlinkTime = 0;
      }

      initializeSession(config) {
        this.currentSession = {
          config,
          gazeData: []
        };
        this.sessionStartTime = Date.now();
        this.lastFixationStart = 0;
        this.lastGazePoint = null;
        this.fixationCount = 0;
        this.totalFixationDuration = 0;
        this.saccadeCount = 0;
        this.totalSaccadeLength = 0;
        this.blinkCount = 0;
        this.lastBlinkTime = Date.now();
      }

      addGazeData(data) {
        if (!this.currentSession.config) {
          throw new Error('No active session');
        }
        const enrichedData = this.calculateMetrics(data);
        this.currentSession.gazeData.push(enrichedData);
        this.lastGazePoint = enrichedData;
        return enrichedData;
      }

      getCurrentSession() {
        return this.currentSession;
      }

      clearSession() {
        this.currentSession = {
          config: null,
          gazeData: []
        };
        this.sessionStartTime = 0;
        this.lastFixationStart = 0;
        this.lastGazePoint = null;
        this.fixationCount = 0;
        this.totalFixationDuration = 0;
        this.saccadeCount = 0;
        this.totalSaccadeLength = 0;
        this.blinkCount = 0;
        this.lastBlinkTime = 0;
      }

      getGazeDataCount() {
        return this.currentSession.gazeData.length;
      }

      formatTime(timestamp) {
        const date = new Date(timestamp);
        return {
          formattedTime: date.toTimeString().split(' ')[0] + '.' + String(date.getMilliseconds()).padStart(3, '0'),
          formattedDate: date.toISOString().split('T')[0]
        };
      }

      formatSessionTime(sessionTime) {
        const minutes = Math.floor(sessionTime / 60000);
        const seconds = Math.floor((sessionTime % 60000) / 1000);
        const milliseconds = sessionTime % 1000;
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
      }

      calculateMetrics(data) {
        const now = Date.now();
        const enrichedData = { ...data };
        const sessionTime = now - this.sessionStartTime;
        const { formattedTime, formattedDate } = this.formatTime(now);

        // Add timestamps
        enrichedData.timestamp = now;
        enrichedData.sessionTime = sessionTime;
        enrichedData.formattedTime = formattedTime;
        enrichedData.formattedDate = formattedDate;
        enrichedData.sessionTimeFormatted = this.formatSessionTime(sessionTime);

        // Calculate fixation and saccade metrics
        if (this.lastGazePoint) {
          const distance = Math.sqrt(
            Math.pow((data.x - this.lastGazePoint.x), 2) + 
            Math.pow((data.y - this.lastGazePoint.y), 2)
          );

          const FIXATION_THRESHOLD = 30;
          if (distance < FIXATION_THRESHOLD) {
            const fixationDuration = now - this.lastFixationStart;
            enrichedData.fixationDuration = fixationDuration;
            this.totalFixationDuration += fixationDuration;
            
            if (!this.lastGazePoint.fixationDuration) {
              this.fixationCount++;
            }
          } else {
            this.lastFixationStart = now;
            enrichedData.saccadeLength = distance;
            this.saccadeCount++;
            this.totalSaccadeLength += distance;
          }

          enrichedData.gazeDistance = distance;
          
          // Calculate velocities
          const timeElapsed = now - this.lastGazePoint.timestamp;
          enrichedData.gazeVelocity = distance / (timeElapsed / 1000); // pixels per second
        } else {
          this.lastFixationStart = now;
        }

        // Detect blinks
        if (data.confidence && data.confidence < 0.1) {
          if (now - this.lastBlinkTime > 300) {
            this.blinkCount++;
            this.lastBlinkTime = now;
          }
        }

        // Calculate aggregate metrics
        const sessionDuration = Math.max((now - this.sessionStartTime) / 1000 / 60, 1/60);
        enrichedData.blinkRate = this.blinkCount / sessionDuration;
        enrichedData.avgFixationDuration = this.totalFixationDuration / Math.max(this.fixationCount, 1);
        enrichedData.fixationsPerMinute = this.fixationCount / sessionDuration;
        enrichedData.avgSaccadeLength = this.totalSaccadeLength / Math.max(this.saccadeCount, 1);
        enrichedData.saccadesPerMinute = this.saccadeCount / sessionDuration;

        return enrichedData;
      }
    }

    // Initialize DataStorageService instance
    let dataStorage = new DataStorageService();

    // Update handleGazeData function to use DataStorageService
    function handleGazeData(GazeData) {
      try {
        if (!tracking || !dataCollectionReady) return;

        const processedData = processGazeData(GazeData);
        if (!processedData) return;

        // Add data to storage service
        const enrichedData = dataStorage.addGazeData(processedData);
        
        // Update UI with enriched data
        updateLiveData(enrichedData);
        
        if (dataStorage.getGazeDataCount() % 50 === 0) {
          const recentData = dataStorage.getCurrentSession().gazeData.slice(-50);
          const avgConfidence = mean(recentData.map(d => d.confidence || 0));
          logMessage(
            `Recording active: ${dataStorage.getGazeDataCount()} points collected | ` +
            `Recent Quality: ${(avgConfidence * 100).toFixed(1)}% | ` +
            `Rate: ${(50000 / (Date.now() - lastUpdate)).toFixed(1)} Hz`,
            avgConfidence > DATA_QUALITY_THRESHOLD ? 'success' : 'warning'
          );
        }
      } catch (error) {
        console.error("Error processing gaze data:", error);
        logMessage("Error processing gaze data: " + error.message, 'error');
      }
    }

    // Update startTracking function to initialize session
    function startTracking() {
      try {
        if (tracking) {
          stopTracking();
          return;
        }

        if (calibrationAttempts >= MAX_CALIBRATION_ATTEMPTS) {
          logMessage(`❌ Too many calibration attempts. Please refresh the page and try again.`, 'error');
          return;
        }

        // Initialize new session
        dataStorage.initializeSession({
          participantId: 'P' + Date.now(),
          isPilot: false
        });

        apiState = API_STATES.INITIALIZING;
        updateConnectionUI('connecting');

        // Clear any existing video elements
        document.querySelectorAll('video').forEach(video => video.remove());

        // Initialize and start tracking with proper sequence
        checkGazeCloudAPI()
          .then(() => {
            debugLog('API check passed, initializing data collection');
            return initializeDataCollection();
          })
          .then((initialized) => {
            if (!initialized) {
              throw new Error("Failed to initialize data collection");
            }
            debugLog('Data collection initialized, preparing to start tracking');
            apiState = API_STATES.CONNECTING;
            
            // Ensure the container is ready
            const container = document.getElementById('liveData');
            if (!container) {
              throw new Error("Container for eye tracking not found");
            }
            container.innerHTML = `
              <div class="calibration-message">
                <h3>🎯 Preparing Eye Tracking</h3>
                <div class="initialization-steps">
                  <div class="step">
                    <span class="step-indicator">⚙️</span>
                    <span class="step-text">Initializing camera...</span>
                  </div>
                </div>
                <div class="progress-bar">
                  <div class="progress-indicator"></div>
                </div>
              </div>
            `;

            // Start eye tracking with a slight delay
            return new Promise((resolve, reject) => {
              setTimeout(() => {
                try {
                  GazeCloudAPI.StartEyeTracking();
                  resolve();
                } catch (error) {
                  reject(new Error("Failed to start eye tracking: " + error.message));
                }
              }, 1000);
            });
          })
          .then(() => {
            logMessage("🎯 Starting eye tracking system...", 'info');
            calibrationAttempts++;
          })
          .catch((error) => {
            apiState = API_STATES.ERROR;
            console.error("Error starting tracking:", error);
            handleGazeError({
              code: ERROR_CODES.INITIALIZATION_ERROR,
              message: "Failed to start tracking: " + error.message
            });
            // Clean up on error
            document.querySelectorAll('video').forEach(video => video.remove());
          });

      } catch (error) {
        apiState = API_STATES.ERROR;
        console.error("Error in startTracking:", error);
        handleGazeError({
          code: ERROR_CODES.INITIALIZATION_ERROR,
          message: "Failed to start tracking: " + error.message
        });
      }
    }

    // Update stopTracking function to handle session data
    function stopTracking() {
      try {
        if (!tracking) return;
        
        GazeCloudAPI.StopEyeTracking();
        tracking = false;
        isCalibrating = false;
        
        // Save session data to IndexedDB
        const session = dataStorage.getCurrentSession();
        if (session && session.gazeData.length > 0) {
          const transaction = db.transaction([STORE_NAME], 'readwrite');
          const store = transaction.objectStore(STORE_NAME);
          
          const sessionData = {
            timestamp: new Date().toISOString(),
            duration: session.gazeData.length > 0 ? 
              (session.gazeData[session.gazeData.length - 1].timestamp - session.gazeData[0].timestamp) / 1000 : 0,
            dataPoints: session.gazeData.length,
            averageConfidence: mean(session.gazeData.map(d => d.confidence || 0)),
            data: session.gazeData,
            config: session.config
          };

          store.add(sessionData).onsuccess = () => {
            logMessage("Session data saved successfully", 'success');
            loadSessions(); // Refresh sessions list
          };
        }
        
        // Clear current session
        dataStorage.clearSession();
        
        // Update UI
        updateUIState(false);
        document.getElementById("liveData").innerHTML = "<em>Live gaze data will appear here...</em>";
        logMessage("Eye tracking stopped.");
      } catch (error) {
        console.error("Error stopping tracking:", error);
        logMessage("Error stopping tracking: " + error.message, 'error');
      }
    }

    // Monitor calibration timeout
    setInterval(() => {
      if (isCalibrating && calibrationStartTime > 0) {
        const calibrationDuration = Date.now() - calibrationStartTime;
        if (calibrationDuration > CALIBRATION_TIMEOUT) {
          logMessage("❌ Calibration timeout reached", 'error');
          handleCalibrationFailure();
        }
      }
    }, 1000);

    // Handle gaze data processing
    function handleGazeData(GazeData) {
      try {
        if (!tracking || !dataCollectionReady) return;

        const processedData = processGazeData(GazeData);
        if (!processedData) return;

        recordedData.push(processedData);
        if (recordedData.length > MAX_RECORDED_POINTS) {
          recordedData = recordedData.slice(-MAX_RECORDED_POINTS);
          logMessage("Trimming recorded data to prevent memory issues", 'warning');
        }

        updateLiveData(processedData);
        
        if (recordedData.length % 50 === 0) {
          const avgConfidence = mean(recordedData.slice(-50).map(d => d.confidence || 0));
          logMessage(
            `Recording active: ${recordedData.length} points collected | ` +
            `Recent Quality: ${(avgConfidence * 100).toFixed(1)}% | ` +
            `Rate: ${(50000 / (Date.now() - lastUpdate)).toFixed(1)} Hz`,
            avgConfidence > DATA_QUALITY_THRESHOLD ? 'success' : 'warning'
          );
        }
      } catch (error) {
        console.error("Error processing gaze data:", error);
        logMessage("Error processing gaze data: " + error.message, 'error');
      }
    }

    // Handle calibration failure
    function handleCalibrationFailure() {
      isCalibrating = false;
      tracking = false;
      dataCollectionReady = false;
      
      document.getElementById("liveData").innerHTML = `
        <div class="calibration-message error">
          <h3>Calibration Failed</h3>
          <p>Please ensure:</p>
          <ul>
            <li>Your face is well-lit and visible</li>
            <li>You are in a stable position</li>
            <li>Your eyes are clearly visible</li>
            <li>You are looking at the calibration points</li>
          </ul>
          <p>Click "Start Tracking" to try again.</p>
        </div>
      `;
      
      logMessage(`Calibration failed (Attempt ${calibrationAttempts} of ${MAX_CALIBRATION_ATTEMPTS})`, 'error');
      updateUIState(false);
    }

    // Handle GazeCloud API errors
    function handleGazeError(msg) {
      tracking = false;
      isCalibrating = false;
      dataCollectionReady = false;
      logMessage("GazeCloud API Error: " + msg, 'error');
      updateUIState(false);
      
      document.getElementById("liveData").innerHTML = `
        <div class="calibration-message error">
          <h3>Eye Tracking Error</h3>
          <p>${msg}</p>
          <p>Please try again or check your camera settings.</p>
        </div>
      `;
    }

    // Validate and process incoming gaze data
    function processGazeData(gazeData) {
      try {
        if (!gazeData || typeof gazeData !== 'object') return null;
        
        // Validate timestamp and ensure proper interval
        const currentTime = Date.now();
        if (lastDataPoint && (currentTime - lastDataPoint.timestamp) < MIN_DATA_INTERVAL) {
          return null;
        }

        // Process and validate coordinates
        const processedData = {
          timestamp: currentTime,
          x: gazeData.docX !== undefined ? gazeData.docX : gazeData.x,
          y: gazeData.docY !== undefined ? gazeData.docY : gazeData.y,
          state: gazeData.state,
          confidence: gazeData.confidence || 0,
          pupilD: gazeData.pupilD,
          HeadX: gazeData.HeadX,
          HeadY: gazeData.HeadY,
          HeadZ: gazeData.HeadZ,
          HeadYaw: gazeData.HeadYaw,
          HeadPitch: gazeData.HeadPitch,
          HeadRoll: gazeData.HeadRoll
        };

        // Validate data quality
        if (processedData.confidence < DATA_QUALITY_THRESHOLD) {
          logMessage("Low confidence data point detected", 'warning');
          return null;
        }

        lastDataPoint = processedData;
        return processedData;
      } catch (error) {
        console.error("Error processing gaze data:", error);
        logMessage("Error processing gaze data: " + error.message, 'error');
        return null;
      }
    }

    // Export the recorded gaze data as a CSV file
    function exportCSV() {
      try {
        if (recordedData.length === 0) {
          logMessage("No data recorded to export.");
          return;
        }
        let csvContent = "data:text/csv;charset=utf-8,";
        csvContent += "timestamp,x,y,state,confidence,pupilD,HeadX,HeadY,HeadZ,HeadYaw,HeadPitch,HeadRoll\n";
        
        recordedData.forEach(function(data) {
          const timestamp = data.time || data.timestamp || '';
          const x = data.docX !== undefined ? data.docX : data.x || '';
          const y = data.docY !== undefined ? data.docY : data.y || '';
          const state = data.state || '';
          const confidence = data.confidence || '';
          const pupilD = data.pupilD || '';
          const HeadX = data.HeadX || '';
          const HeadY = data.HeadY || '';
          const HeadZ = data.HeadZ || '';
          const HeadYaw = data.HeadYaw || '';
          const HeadPitch = data.HeadPitch || '';
          const HeadRoll = data.HeadRoll || '';
          
          csvContent += `${timestamp},${x},${y},${state},${confidence},${pupilD},${HeadX},${HeadY},${HeadZ},${HeadYaw},${HeadPitch},${HeadRoll}\n`;
        });

        const encodedUri = encodeURI(csvContent);
        const link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", "gaze_data_" + Date.now() + ".csv");
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        logMessage("CSV export completed.");
      } catch (error) {
        console.error("Error in exportCSV:", error);
        logMessage("Failed to export CSV: " + error.message);
      }
    }

    // Clear recorded data and reset the live display
    function clearData() {
      try {
        recordedData = [];
        document.getElementById("liveData").innerHTML = "<em>Live gaze data will appear here...</em>";
        logMessage("Cleared recorded data.");
      } catch (error) {
        console.error("Error in clearData:", error);
      }
    }

    /********** CSV ANALYSIS DASHBOARD SECTION **********/
    // Compute basic statistics from CSV data
    function computeBasicStats(data) {
      try {
        const validConfidence = data.filter(d => d.confidence !== undefined && d.confidence !== null && d.confidence !== '');
        const validPupilData = data.filter(d => d.pupilD !== undefined && d.pupilD !== null && d.pupilD !== '');
        const validHeadData = data.filter(d => 
          d.HeadX !== undefined && d.HeadY !== undefined && d.HeadZ !== undefined &&
          d.HeadX !== null && d.HeadY !== null && d.HeadZ !== null &&
          d.HeadX !== '' && d.HeadY !== '' && d.HeadZ !== ''
        );

        let avgConfidence = validConfidence.length ? (mean(validConfidence.map(d => d.confidence)) * 100).toFixed(1) + '%' : 'N/A';
        let pupilMean = validPupilData.length ? mean(validPupilData.map(d => d.pupilD)).toFixed(2) : 'N/A';
        let pupilMin = validPupilData.length ? Math.min(...validPupilData.map(d => d.pupilD)).toFixed(2) : 'N/A';
        let pupilMax = validPupilData.length ? Math.max(...validPupilData.map(d => d.pupilD)).toFixed(2) : 'N/A';
        let pupilStdDev = validPupilData.length ? standardDeviation(validPupilData.map(d => d.pupilD)).toFixed(2) : 'N/A';

        let headXMean = validHeadData.length ? mean(validHeadData.map(d => d.HeadX)).toFixed(1) : 'N/A';
        let headYMean = validHeadData.length ? mean(validHeadData.map(d => d.HeadY)).toFixed(1) : 'N/A';
        let headZMean = validHeadData.length ? mean(validHeadData.map(d => d.HeadZ)).toFixed(1) : 'N/A';

        const validHeadYaw = data.filter(d => d.HeadYaw !== undefined && d.HeadYaw !== null && d.HeadYaw !== '');
        const validHeadPitch = data.filter(d => d.HeadPitch !== undefined && d.HeadPitch !== null && d.HeadPitch !== '');
        const validHeadRoll = data.filter(d => d.HeadRoll !== undefined && d.HeadRoll !== null && d.HeadRoll !== '');

        let headYawMean = validHeadYaw.length ? mean(validHeadYaw.map(d => d.HeadYaw)).toFixed(1) : 'N/A';
        let headPitchMean = validHeadPitch.length ? mean(validHeadPitch.map(d => d.HeadPitch)).toFixed(1) : 'N/A';
        let headRollMean = validHeadRoll.length ? mean(validHeadRoll.map(d => d.HeadRoll)).toFixed(1) : 'N/A';

        return {
          "Total Data Points": data.length,
          "Valid Data Points": validConfidence.length,
          "Average Confidence": avgConfidence,
          "Pupil Diameter (mm)": {
            "Mean": pupilMean,
            "Min": pupilMin,
            "Max": pupilMax,
            "StdDev": pupilStdDev
          },
          "Head Position": {
            "X Mean": headXMean,
            "Y Mean": headYMean,
            "Z Mean": headZMean
          },
          "Head Rotation (degrees)": {
            "Yaw": headYawMean,
            "Pitch": headPitchMean,
            "Roll": headRollMean
          }
        };
      } catch (error) {
        console.error("Error in computeBasicStats:", error);
        return {};
      }
    }

    // Basic helper functions with error handling
    function mean(arr) {
      try {
        if (!Array.isArray(arr) || !arr.length) return 0;
        return arr.reduce((a, b) => a + b, 0) / arr.length;
      } catch (error) {
        console.error("Error in mean calculation:", error);
        return 0;
      }
    }

    function variance(arr) {
      try {
        if (!Array.isArray(arr) || !arr.length) return 0;
        const m = mean(arr);
        return mean(arr.map(x => (x - m) ** 2));
      } catch (error) {
        console.error("Error in variance calculation:", error);
        return 0;
      }
    }

    function standardDeviation(arr) {
      try {
        return Math.sqrt(variance(arr));
      } catch (error) {
        console.error("Error in standardDeviation calculation:", error);
        return 0;
      }
    }

    // Update the statistics display with error handling
    function updateBasicStats(stats) {
      try {
        const container = document.getElementById('basicStats');
        if (!container) return;
        
        container.innerHTML = '';
        for (const [key, value] of Object.entries(stats)) {
          const card = document.createElement('div');
          card.className = 'stat-card';
          if (typeof value === 'object') {
            let content = `<h3>${key}</h3>`;
            for (const [subKey, subValue] of Object.entries(value)) {
              content += `<p><strong>${subKey}:</strong> ${subValue}</p>`;
            }
            card.innerHTML = content;
          } else {
            card.innerHTML = `<h3>${key}</h3><p>${value}</p>`;
          }
          container.appendChild(card);
        }
      } catch (error) {
        console.error("Error in updateBasicStats:", error);
      }
    }

    // Create visualization charts with error handling
    function createEyeMovementChart(data) {
      try {
        const canvas = document.getElementById('eyeMovementChart');
        if (!canvas) {
          logMessage("Eye movement chart canvas not found", 'error');
          return;
        }

        const ctx = canvas.getContext('2d');
        
        // Safely destroy existing chart
        if (window.eyeMovementChart && typeof window.eyeMovementChart.destroy === 'function') {
          window.eyeMovementChart.destroy();
        }
        window.eyeMovementChart = null;

        const validData = data.filter(d =>
          ((d.x !== undefined && d.x !== '' && d.x !== null) || (d.docX !== undefined && d.docX !== '' && d.docX !== null)) &&
          ((d.y !== undefined && d.y !== '' && d.y !== null) || (d.docY !== undefined && d.docY !== '' && d.docY !== null)) &&
          d.timestamp
        );

        if (!validData.length) {
          logMessage("No valid data for eye movement chart", 'warning');
          return;
        }

        const points = validData.map(d => ({
          x: d.x !== undefined && d.x !== '' ? d.x : d.docX,
          y: d.y !== undefined && d.y !== '' ? d.y : d.docY,
          timestamp: new Date(d.timestamp).getTime()
        }));

        const startTime = points[0].timestamp;
        const endTime = points[points.length - 1].timestamp;

        points.forEach(p => {
          const progress = (p.timestamp - startTime) / (endTime - startTime);
          p.color = `hsl(${200 + progress * 160}, 70%, 50%)`;
        });

        window.eyeMovementChart = new Chart(ctx, {
          type: 'scatter',
          data: {
            datasets: [{
              label: 'Gaze Path',
              data: points,
              backgroundColor: points.map(p => p.color),
              pointRadius: 4,
              pointHoverRadius: 6
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                reverse: true,
                title: { display: true, text: 'Y Position (pixels)' }
              },
              x: {
                title: { display: true, text: 'X Position (pixels)' }
              }
            },
            plugins: {
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const point = context.raw;
                    return [
                      `Position: (${point.x.toFixed(1)}, ${point.y.toFixed(1)})`,
                      `Time: ${new Date(point.timestamp).toLocaleTimeString()}`
                    ];
                  }
                }
              }
            }
          }
        });
      } catch (error) {
        console.error("Error creating eye movement chart:", error);
        logMessage("Failed to create eye movement chart");
      }
    }

    function createPupilDilationChart(data) {
      try {
        const canvas = document.getElementById('pupilDilationChart');
        if (!canvas) {
          logMessage("Pupil dilation chart canvas not found", 'error');
          return;
        }

        const ctx = canvas.getContext('2d');
        
        // Safely destroy existing chart
        if (window.pupilDilationChart && typeof window.pupilDilationChart.destroy === 'function') {
          window.pupilDilationChart.destroy();
        }
        window.pupilDilationChart = null;

        const validData = data.filter(d => d.pupilD !== undefined && d.pupilD !== null && d.pupilD !== '' && d.timestamp);
        
        if (!validData.length) {
          logMessage("No valid data for pupil dilation chart", 'warning');
          return;
        }

        const timestamps = validData.map(d => new Date(d.timestamp));

        window.pupilDilationChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: timestamps,
            datasets: [{
              label: 'Pupil Diameter (mm)',
              data: validData.map(d => ({ x: new Date(d.timestamp), y: d.pupilD })),
              borderColor: 'rgba(75, 192, 192, 1)',
              backgroundColor: 'rgba(75, 192, 192, 0.2)',
              fill: true,
              tension: 0.4
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                type: 'time',
                time: { unit: 'second', displayFormats: { second: 'HH:mm:ss' } },
                title: { display: true, text: 'Time' }
              },
              y: {
                title: { display: true, text: 'Pupil Diameter (mm)' }
              }
            }
          }
        });
      } catch (error) {
        console.error("Error creating pupil dilation chart:", error);
        logMessage("Failed to create pupil dilation chart");
      }
    }

    function createHeadMovementChart(data) {
      try {
        const canvas = document.getElementById('headMovementChart');
        if (!canvas) {
          logMessage("Head movement chart canvas not found", 'error');
          return;
        }

        const ctx = canvas.getContext('2d');
        
        // Safely destroy existing chart
        if (window.headMovementChart && typeof window.headMovementChart.destroy === 'function') {
          window.headMovementChart.destroy();
        }
        window.headMovementChart = null;

        const validData = data.filter(d =>
          d.HeadX !== undefined && d.HeadY !== undefined && d.HeadZ !== undefined &&
          d.HeadX !== null && d.HeadY !== null && d.HeadZ !== null &&
          d.HeadX !== '' && d.HeadY !== '' && d.HeadZ !== '' && d.timestamp
        );

        if (!validData.length) {
          logMessage("No valid data for head movement chart", 'warning');
          return;
        }

        const timestamps = validData.map(d => new Date(d.timestamp));

        window.headMovementChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: timestamps,
            datasets: [
              {
                label: 'Head X',
                data: validData.map(d => ({ x: new Date(d.timestamp), y: d.HeadX })),
                borderColor: 'rgba(255, 99, 132, 1)',
                tension: 0.4
              },
              {
                label: 'Head Y',
                data: validData.map(d => ({ x: new Date(d.timestamp), y: d.HeadY })),
                borderColor: 'rgba(54, 162, 235, 1)',
                tension: 0.4
              },
              {
                label: 'Head Z',
                data: validData.map(d => ({ x: new Date(d.timestamp), y: d.HeadZ })),
                borderColor: 'rgba(75, 192, 192, 1)',
                tension: 0.4
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                type: 'time',
                time: { unit: 'second', displayFormats: { second: 'HH:mm:ss' } },
                title: { display: true, text: 'Time' }
              },
              y: {
                title: { display: true, text: 'Head Position' }
              }
            }
          }
        });
      } catch (error) {
        console.error("Error creating head movement chart:", error);
        logMessage("Failed to create head movement chart");
      }
    }

    // Process uploaded CSV file with enhanced error handling
    function processFile() {
      try {
        const fileInput = document.getElementById('csvFile');
        const file = fileInput.files[0];
        
        if (!file) {
          alert('Please select a CSV file first.');
          return;
        }

        Papa.parse(file, {
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true,
          complete: function(results) {
            try {
              if (results.errors.length > 0) {
                console.error('CSV parsing errors:', results.errors);
                alert('Error parsing CSV file. Please check the console for details.');
                return;
              }

              const data = results.data.filter(row => row.timestamp != null && row.timestamp !== '');
              
              if (data.length === 0) {
                alert('No valid data found in the CSV file.');
                return;
              }

              const stats = computeBasicStats(data);
              updateBasicStats(stats);
              createEyeMovementChart(data);
              createPupilDilationChart(data);
              createHeadMovementChart(data);
              
              logMessage(`Successfully processed ${data.length} data points`);
            } catch (error) {
              console.error("Error in Papa.parse complete callback:", error);
              alert('Error processing CSV data: ' + error.message);
            }
          },
          error: function(error) {
            console.error('Error parsing CSV:', error);
            alert('Failed to parse CSV file: ' + error.message);
          }
        });
      } catch (error) {
        console.error("Error in processFile:", error);
        alert('Error processing file: ' + error.message);
      }
    }

    // Add window error handler for uncaught errors
    window.onerror = function(message, source, lineno, colno, error) {
      console.error("Global error:", {message, source, lineno, colno, error});
      logMessage(`Uncaught error: ${message}`);
      return false;
    };

    // Add chart toggle functionality
    function toggleChart(chartId) {
      // Hide all charts
      document.querySelectorAll('.chart-container').forEach(container => {
        container.classList.remove('active');
      });
      
      // Deactivate all toggle buttons
      document.querySelectorAll('.chart-toggle').forEach(button => {
        button.classList.remove('active');
      });
      
      // Show selected chart and activate its toggle
      document.getElementById(chartId + 'Container').classList.add('active');
      document.getElementById(chartId + 'Toggle').classList.add('active');
    }
    
    // Initialize with eye movement chart visible and theme
    window.addEventListener('load', function() {
      toggleChart('eyeMovement');
      initializeTheme();
      initDB()
        .then(() => loadSessions())
        .catch(error => {
          logMessage("Error initializing database: " + error.message, 'error');
        });
    });

    // Add window focus/blur handlers
    window.addEventListener('blur', function() {
      if (tracking) {
        logMessage("Window lost focus. Consider recalibrating if tracking accuracy decreases.", 'warning');
      }
    });

    // Add connection status check
    window.addEventListener('online', function() {
      logMessage("Internet connection restored.", 'success');
    });

    window.addEventListener('offline', function() {
      logMessage("Internet connection lost. Tracking may be affected.", 'error');
      if (tracking) {
        stopTracking();
      }
    });

    // Add beforeunload handler
    window.addEventListener('beforeunload', function(e) {
      if (tracking || recordedData.length > 0) {
        const message = "You have active tracking or unsaved data. Are you sure you want to leave?";
        e.returnValue = message;
        return message;
      }
    });

    // Add connection handling variables
    let connectionAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 3;
    const RECONNECT_DELAY = 2000; // 2 seconds

    // Handle connection loss
    function handleConnectionLost() {
      tracking = false;
      isCalibrating = false;
      dataCollectionReady = false;

      logMessage("GazeCloud server connection lost!", 'error');
      
      // Show connection loss message
      document.getElementById("liveData").innerHTML = `
        <div class="calibration-message error">
          <h3>Connection Lost</h3>
          <p>Lost connection to the GazeCloud server. ${connectionAttempts < MAX_RECONNECT_ATTEMPTS ? 'Attempting to reconnect...' : 'Please refresh the page to try again.'}</p>
          <div class="initialization-steps">
            <div class="step">
              <span class="step-indicator">🔄</span>
              <span class="step-text">Reconnection attempt ${connectionAttempts + 1}/${MAX_RECONNECT_ATTEMPTS}</span>
            </div>
          </div>
        </div>
      `;

      // Attempt to reconnect if within retry limit
      if (connectionAttempts < MAX_RECONNECT_ATTEMPTS) {
        connectionAttempts++;
        setTimeout(() => {
          logMessage(`Attempting to reconnect (${connectionAttempts}/${MAX_RECONNECT_ATTEMPTS})...`, 'info');
          try {
            // Clean up existing connection
            if (typeof GazeCloudAPI !== 'undefined' && GazeCloudAPI.StopEyeTracking) {
              GazeCloudAPI.StopEyeTracking();
            }
            // Remove any existing video elements
            document.querySelectorAll('video').forEach(video => video.remove());
            // Attempt to reinitialize
            startTracking();
          } catch (error) {
            console.error("Error during reconnection attempt:", error);
            logMessage("Failed to reconnect: " + error.message, 'error');
          }
        }, RECONNECT_DELAY);
      } else {
        logMessage("Maximum reconnection attempts reached. Please refresh the page.", 'error');
        document.getElementById("liveData").innerHTML = `
          <div class="calibration-message error">
            <h3>Connection Failed</h3>
            <p>Unable to reconnect to the GazeCloud server after multiple attempts.</p>
            <p>Please check your internet connection and refresh the page to try again.</p>
          </div>
        `;
      }
    }
  </script>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Eye Tracking Recorder & Analysis Dashboard</h1>
      <!-- Theme toggle will be inserted here by JavaScript -->
    </div>
    
    <!-- LIVE TRACKING SECTION -->
    <section id="liveTrackingSection">
      <h2>Live Eye Tracking Recorder</h2>
      <div id="liveControls">
        <button type="button" onclick="startTracking()">Start Tracking</button>
        <button type="button" onclick="stopTracking()">Stop Tracking</button>
        <button type="button" onclick="exportCSV()">Export CSV</button>
        <button type="button" onclick="clearData()">Clear Data</button>
      </div>
      <div id="liveData">
        <em>Live gaze data will appear here...</em>
      </div>
      <div id="debugLog">
        <em>Debug log messages will appear here...</em>
      </div>
    </section>

    <hr>

    <!-- SESSIONS LIST SECTION -->
    <section id="sessionsListSection">
      <h2>Recorded Sessions</h2>
      <div class="sessions-container">
        <div id="sessionsList">
          <em>No sessions recorded yet...</em>
        </div>
      </div>
    </section>

    <hr>

    <!-- CSV ANALYSIS DASHBOARD SECTION -->
    <section id="analysisDashboardSection">
      <h2>CSV Data Analysis Dashboard</h2>
      <div class="file-input">
        <label for="csvFile">Select CSV File:</label>
        <input type="file" id="csvFile" accept=".csv" title="Upload gaze tracking data CSV file">
        <button type="button" onclick="processFile()">Analyze Data</button>
      </div>
      <div class="stats-container" id="basicStats"></div>
      <div class="chart-controls">
        <button type="button" id="eyeMovementToggle" class="chart-toggle red active" onclick="toggleChart('eyeMovement')">Eye Movement</button>
        <button type="button" id="pupilDilationToggle" class="chart-toggle green" onclick="toggleChart('pupilDilation')">Pupil Dilation</button>
        <button type="button" id="headMovementToggle" class="chart-toggle blue" onclick="toggleChart('headMovement')">Head Movement</button>
      </div>
      <div id="eyeMovementContainer" class="chart-container active">
        <h3>Eye Movement Trajectory</h3>
        <canvas id="eyeMovementChart"></canvas>
      </div>
      <div id="pupilDilationContainer" class="chart-container">
        <h3>Pupil Dilation Over Time</h3>
        <canvas id="pupilDilationChart"></canvas>
      </div>
      <div id="headMovementContainer" class="chart-container">
        <h3>Head Displacement Over Time</h3>
        <canvas id="headMovementChart"></canvas>
      </div>
    </section>
  </div>
</body>
</html>
