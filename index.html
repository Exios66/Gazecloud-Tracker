<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Eye Tracking Recorder & Analysis Dashboard</title>
  <!-- GazeCloudAPI for live tracking -->
  <script src="https://api.gazerecorder.com/GazeCloudAPI.js"></script>
  <!-- Chart.js for visualizations -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
  <!-- PapaParse for CSV processing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f5f5f5;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    h1, h2, h3 {
      color: #333;
    }
    hr {
      margin: 40px 0;
      border: none;
      border-top: 1px solid #ddd;
    }
    button {
      margin: 5px;
      padding: 10px 15px;
      font-size: 1em;
      cursor: pointer;
    }
    #liveData, #debugLog {
      background-color: #fff;
      border: 1px solid #ddd;
      padding: 10px;
      margin: 10px 0;
    }
    #liveData {
      min-height: 50px;
    }
    #debugLog {
      max-height: 200px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.9em;
      white-space: pre-wrap;
    }
    .file-input, .stats-container, .chart-container {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 30px;
    }
    .stats-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
    }
    .stat-card {
      background: #fff;
      padding: 15px;
      border-radius: 6px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.08);
    }
    .chart-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      justify-content: center;
    }
    
    .chart-toggle {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      opacity: 0.7;
    }
    
    .chart-toggle.active {
      opacity: 1;
      transform: scale(1.05);
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    
    .chart-toggle.red { background-color: rgba(255, 99, 132, 0.2); color: rgb(255, 99, 132); }
    .chart-toggle.green { background-color: rgba(75, 192, 192, 0.2); color: rgb(75, 192, 192); }
    .chart-toggle.blue { background-color: rgba(54, 162, 235, 0.2); color: rgb(54, 162, 235); }
    
    .chart-toggle.red.active { background-color: rgba(255, 99, 132, 0.4); }
    .chart-toggle.green.active { background-color: rgba(75, 192, 192, 0.4); }
    .chart-toggle.blue.active { background-color: rgba(54, 162, 235, 0.4); }
    
    .chart-container {
      display: none;
      transition: opacity 0.3s ease;
    }
    
    .chart-container.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
  </style>
  <script>
    /********** LIVE EYE TRACKING SECTION **********/
    let recordedData = [];
    let tracking = false;
    let lastUpdate = 0;
    let calibrationAttempts = 0;
    let isCalibrating = false;
    let dataCollectionReady = false;
    let lastDataPoint = null;
    const UPDATE_INTERVAL = 50; // ms
    const MAX_RECORDED_POINTS = 10000;
    const MAX_CALIBRATION_ATTEMPTS = 3;
    const CALIBRATION_TIMEOUT = 30000; // 30 seconds
    const MIN_DATA_INTERVAL = 16; // Minimum interval between data points (ms)
    const DATA_QUALITY_THRESHOLD = 0.6; // Minimum confidence threshold

    // Update UI state
    function updateUIState(isRecording) {
      try {
        const startBtn = document.querySelector('button[onclick="startTracking()"]');
        const stopBtn = document.querySelector('button[onclick="stopTracking()"]');
        const exportBtn = document.querySelector('button[onclick="exportCSV()"]');
        const clearBtn = document.querySelector('button[onclick="clearData()"]');
        
        if (startBtn) startBtn.disabled = isRecording;
        if (stopBtn) stopBtn.disabled = !isRecording;
        if (exportBtn) exportBtn.disabled = !recordedData.length;
        if (clearBtn) clearBtn.disabled = !recordedData.length;
      } catch (error) {
        console.error("Error updating UI state:", error);
      }
    }

    // Enhanced logging with severity levels
    function logMessage(message, level = 'info') {
      try {
        const logDiv = document.getElementById("debugLog");
        const timestamp = new Date().toLocaleTimeString();
        const logLevels = {
          error: 'üî¥',
          warning: 'üü°',
          success: 'üü¢',
          info: '‚ÑπÔ∏è'
        };
        const logEntry = `[${timestamp}] ${logLevels[level] || '‚ÑπÔ∏è'} ${message}\n`;
        
        logDiv.textContent += logEntry;
        logDiv.scrollTop = logDiv.scrollHeight;
        
        // Console logging with appropriate methods
        switch(level) {
          case 'error':
            console.error(message);
            break;
          case 'warning':
            console.warn(message);
            break;
          default:
            console.log(message);
        }
      } catch (error) {
        console.error("Error in logMessage:", error);
      }
    }

    // Update the live data display with the most recent gaze values
    function updateLiveData(data) {
      try {
        const now = Date.now();
        if (now - lastUpdate < UPDATE_INTERVAL) return;
        lastUpdate = now;

        const liveDiv = document.getElementById("liveData");
        if (!liveDiv) return;

        liveDiv.innerHTML = `
          <strong>Latest Gaze Data:</strong><br>
          State: ${data.state || 'N/A'}<br>
          X: ${data.docX || data.x || 'N/A'}<br>
          Y: ${data.docY || data.y || 'N/A'}<br>
          Timestamp: ${data.time || data.timestamp || 'N/A'}
        `;
      } catch (error) {
        console.error("Error in updateLiveData:", error);
      }
    }

    // Initialize data collection system
    function initializeDataCollection() {
      try {
        dataCollectionReady = false;
        recordedData = [];
        lastDataPoint = null;
        
        // Set up data collection configuration
        const config = {
          sampleRate: 1000 / UPDATE_INTERVAL,
          confidenceThreshold: DATA_QUALITY_THRESHOLD,
          enableHeadTracking: true,
          enablePupilTracking: true
        };

        logMessage("Initializing data collection system...", 'info');
        
        // Verify GazeCloudAPI availability
        if (typeof GazeCloudAPI === 'undefined') {
          throw new Error("GazeCloudAPI not loaded");
        }

        // Initialize data structures
        resetDataStructures();
        
        dataCollectionReady = true;
        logMessage("Data collection system initialized successfully", 'success');
        return true;
      } catch (error) {
        console.error("Error initializing data collection:", error);
        logMessage("Failed to initialize data collection: " + error.message, 'error');
        return false;
      }
    }

    // Reset all data structures
    function resetDataStructures() {
      try {
        // Safely destroy existing charts
        function safeDestroyChart(chartInstance) {
          try {
            if (chartInstance && typeof chartInstance.destroy === 'function') {
              chartInstance.destroy();
            }
          } catch (error) {
            console.error("Error destroying chart:", error);
          }
        }

        // Clear existing charts with safety checks
        if (window.eyeMovementChart) {
          safeDestroyChart(window.eyeMovementChart);
          window.eyeMovementChart = null;
        }
        if (window.pupilDilationChart) {
          safeDestroyChart(window.pupilDilationChart);
          window.pupilDilationChart = null;
        }
        if (window.headMovementChart) {
          safeDestroyChart(window.headMovementChart);
          window.headMovementChart = null;
        }

        // Clear chart canvases
        function clearCanvas(canvasId) {
          try {
            const canvas = document.getElementById(canvasId);
            if (canvas) {
              const ctx = canvas.getContext('2d');
              ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
          } catch (error) {
            console.error(`Error clearing canvas ${canvasId}:`, error);
          }
        }

        clearCanvas('eyeMovementChart');
        clearCanvas('pupilDilationChart');
        clearCanvas('headMovementChart');
        
        // Reset data arrays
        recordedData = [];
        lastDataPoint = null;
        
        // Reset UI elements
        document.getElementById("liveData").innerHTML = "<em>Live gaze data will appear here...</em>";
        updateUIState(false);
        
        logMessage("Data structures reset successfully", 'info');
      } catch (error) {
        console.error("Error resetting data structures:", error);
        logMessage("Failed to reset data structures: " + error.message, 'error');
      }
    }

    // Validate and process incoming gaze data
    function processGazeData(gazeData) {
      try {
        if (!gazeData || typeof gazeData !== 'object') return null;
        
        // Validate timestamp and ensure proper interval
        const currentTime = Date.now();
        if (lastDataPoint && (currentTime - lastDataPoint.timestamp) < MIN_DATA_INTERVAL) {
          return null;
        }

        // Process and validate coordinates
        const processedData = {
          timestamp: currentTime,
          x: gazeData.docX !== undefined ? gazeData.docX : gazeData.x,
          y: gazeData.docY !== undefined ? gazeData.docY : gazeData.y,
          state: gazeData.state,
          confidence: gazeData.confidence || 0,
          pupilD: gazeData.pupilD,
          HeadX: gazeData.HeadX,
          HeadY: gazeData.HeadY,
          HeadZ: gazeData.HeadZ,
          HeadYaw: gazeData.HeadYaw,
          HeadPitch: gazeData.HeadPitch,
          HeadRoll: gazeData.HeadRoll
        };

        // Validate data quality
        if (processedData.confidence < DATA_QUALITY_THRESHOLD) {
          logMessage("Low confidence data point detected", 'warning');
          return null;
        }

        lastDataPoint = processedData;
        return processedData;
      } catch (error) {
        console.error("Error processing gaze data:", error);
        logMessage("Error processing gaze data: " + error.message, 'error');
        return null;
      }
    }

    // Start eye tracking with enhanced initialization
    function startTracking() {
      try {
        if (tracking) {
          stopTracking();
          return;
        }

        if (calibrationAttempts >= MAX_CALIBRATION_ATTEMPTS) {
          const retryDelay = 60;
          logMessage(`Too many calibration attempts. Please wait ${retryDelay} seconds before trying again.`, 'error');
          setTimeout(() => { calibrationAttempts = 0; }, retryDelay * 1000);
          return;
        }

        // Initialize data collection system
        if (!initializeDataCollection()) {
          logMessage("Failed to initialize data collection system", 'error');
          return;
        }

        isCalibrating = true;
        calibrationAttempts++;

        // Set up calibration timeout
        const calibrationTimeout = setTimeout(() => {
          if (isCalibrating) {
            logMessage("Calibration timed out. Please try again.", 'error');
            stopTracking();
          }
        }, CALIBRATION_TIMEOUT);

        // Enhanced GazeCloud API configuration
        GazeCloudAPI.OnCalibrationComplete = function() {
          clearTimeout(calibrationTimeout);
          isCalibrating = false;
          tracking = true;
          calibrationAttempts = 0;
          logMessage("Calibration completed successfully! Beginning data collection...", 'success');
          updateUIState(true);
        };

        GazeCloudAPI.OnResult = function(GazeData) {
          try {
            if (!tracking || !dataCollectionReady) return;

            const processedData = processGazeData(GazeData);
            if (!processedData) return;

            recordedData.push(processedData);
            if (recordedData.length > MAX_RECORDED_POINTS) {
              recordedData = recordedData.slice(-MAX_RECORDED_POINTS);
              logMessage("Trimming recorded data to prevent memory issues", 'warning');
            }

            updateLiveData(processedData);
            if (recordedData.length % 100 === 0) {
              logMessage(`Recording gaze data... (${recordedData.length} points, Quality: ${(processedData.confidence * 100).toFixed(1)}%)`, 'info');
            }
          } catch (error) {
            console.error("Error in OnResult callback:", error);
            logMessage("Error processing gaze data: " + error.message, 'error');
          }
        };

        // Enhanced error handling callbacks
        GazeCloudAPI.OnCalibrationFail = function() {
          clearTimeout(calibrationTimeout);
          isCalibrating = false;
          tracking = false;
          dataCollectionReady = false;
          logMessage(`Calibration failed (Attempt ${calibrationAttempts} of ${MAX_CALIBRATION_ATTEMPTS})`, 'error');
          updateUIState(false);
        };

        GazeCloudAPI.OnCamDenied = function() {
          clearTimeout(calibrationTimeout);
          isCalibrating = false;
          tracking = false;
          dataCollectionReady = false;
          logMessage("Camera access denied. Please check your camera permissions and ensure no other application is using it.", 'error');
          updateUIState(false);
        };

        GazeCloudAPI.OnError = function(msg) {
          clearTimeout(calibrationTimeout);
          isCalibrating = false;
          tracking = false;
          dataCollectionReady = false;
          logMessage("GazeCloudAPI Error: " + msg, 'error');
          updateUIState(false);
        };

        // Start the calibration and tracking process
        logMessage("Starting calibration process... Please follow the on-screen instructions.", 'info');
        updateUIState(false);
        GazeCloudAPI.StartEyeTracking();
        
      } catch (error) {
        console.error("Error in startTracking:", error);
        tracking = false;
        isCalibrating = false;
        dataCollectionReady = false;
        logMessage("Failed to start tracking: " + error.message, 'error');
        updateUIState(false);
      }
    }

    // Enhanced stop tracking function
    function stopTracking() {
      try {
        GazeCloudAPI.StopEyeTracking();
        tracking = false;
        isCalibrating = false;
        dataCollectionReady = false;
        
        const message = recordedData.length > 0 
          ? `Stopped eye tracking. Recorded ${recordedData.length} data points.`
          : "Stopped eye tracking. No data was recorded.";
        
        logMessage(message, recordedData.length > 0 ? 'success' : 'warning');
        updateUIState(false);
      } catch (error) {
        console.error("Error in stopTracking:", error);
        tracking = false;
        isCalibrating = false;
        dataCollectionReady = false;
        logMessage("Error stopping tracking: " + error.message, 'error');
        updateUIState(false);
      }
    }

    // Export the recorded gaze data as a CSV file
    function exportCSV() {
      try {
        if (recordedData.length === 0) {
          logMessage("No data recorded to export.");
          return;
        }
        let csvContent = "data:text/csv;charset=utf-8,";
        csvContent += "timestamp,x,y,state,confidence,pupilD,HeadX,HeadY,HeadZ,HeadYaw,HeadPitch,HeadRoll\n";
        
        recordedData.forEach(function(data) {
          const timestamp = data.time || data.timestamp || '';
          const x = data.docX !== undefined ? data.docX : data.x || '';
          const y = data.docY !== undefined ? data.docY : data.y || '';
          const state = data.state || '';
          const confidence = data.confidence || '';
          const pupilD = data.pupilD || '';
          const HeadX = data.HeadX || '';
          const HeadY = data.HeadY || '';
          const HeadZ = data.HeadZ || '';
          const HeadYaw = data.HeadYaw || '';
          const HeadPitch = data.HeadPitch || '';
          const HeadRoll = data.HeadRoll || '';
          
          csvContent += `${timestamp},${x},${y},${state},${confidence},${pupilD},${HeadX},${HeadY},${HeadZ},${HeadYaw},${HeadPitch},${HeadRoll}\n`;
        });

        const encodedUri = encodeURI(csvContent);
        const link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", "gaze_data_" + Date.now() + ".csv");
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        logMessage("CSV export completed.");
      } catch (error) {
        console.error("Error in exportCSV:", error);
        logMessage("Failed to export CSV: " + error.message);
      }
    }

    // Clear recorded data and reset the live display
    function clearData() {
      try {
        recordedData = [];
        document.getElementById("liveData").innerHTML = "<em>Live gaze data will appear here...</em>";
        logMessage("Cleared recorded data.");
      } catch (error) {
        console.error("Error in clearData:", error);
      }
    }

    /********** CSV ANALYSIS DASHBOARD SECTION **********/
    // Compute basic statistics from CSV data
    function computeBasicStats(data) {
      try {
        const validConfidence = data.filter(d => d.confidence !== undefined && d.confidence !== null && d.confidence !== '');
        const validPupilData = data.filter(d => d.pupilD !== undefined && d.pupilD !== null && d.pupilD !== '');
        const validHeadData = data.filter(d => 
          d.HeadX !== undefined && d.HeadY !== undefined && d.HeadZ !== undefined &&
          d.HeadX !== null && d.HeadY !== null && d.HeadZ !== null &&
          d.HeadX !== '' && d.HeadY !== '' && d.HeadZ !== ''
        );

        let avgConfidence = validConfidence.length ? (mean(validConfidence.map(d => d.confidence)) * 100).toFixed(1) + '%' : 'N/A';
        let pupilMean = validPupilData.length ? mean(validPupilData.map(d => d.pupilD)).toFixed(2) : 'N/A';
        let pupilMin = validPupilData.length ? Math.min(...validPupilData.map(d => d.pupilD)).toFixed(2) : 'N/A';
        let pupilMax = validPupilData.length ? Math.max(...validPupilData.map(d => d.pupilD)).toFixed(2) : 'N/A';
        let pupilStdDev = validPupilData.length ? standardDeviation(validPupilData.map(d => d.pupilD)).toFixed(2) : 'N/A';

        let headXMean = validHeadData.length ? mean(validHeadData.map(d => d.HeadX)).toFixed(1) : 'N/A';
        let headYMean = validHeadData.length ? mean(validHeadData.map(d => d.HeadY)).toFixed(1) : 'N/A';
        let headZMean = validHeadData.length ? mean(validHeadData.map(d => d.HeadZ)).toFixed(1) : 'N/A';

        const validHeadYaw = data.filter(d => d.HeadYaw !== undefined && d.HeadYaw !== null && d.HeadYaw !== '');
        const validHeadPitch = data.filter(d => d.HeadPitch !== undefined && d.HeadPitch !== null && d.HeadPitch !== '');
        const validHeadRoll = data.filter(d => d.HeadRoll !== undefined && d.HeadRoll !== null && d.HeadRoll !== '');

        let headYawMean = validHeadYaw.length ? mean(validHeadYaw.map(d => d.HeadYaw)).toFixed(1) : 'N/A';
        let headPitchMean = validHeadPitch.length ? mean(validHeadPitch.map(d => d.HeadPitch)).toFixed(1) : 'N/A';
        let headRollMean = validHeadRoll.length ? mean(validHeadRoll.map(d => d.HeadRoll)).toFixed(1) : 'N/A';

        return {
          "Total Data Points": data.length,
          "Valid Data Points": validConfidence.length,
          "Average Confidence": avgConfidence,
          "Pupil Diameter (mm)": {
            "Mean": pupilMean,
            "Min": pupilMin,
            "Max": pupilMax,
            "StdDev": pupilStdDev
          },
          "Head Position": {
            "X Mean": headXMean,
            "Y Mean": headYMean,
            "Z Mean": headZMean
          },
          "Head Rotation (degrees)": {
            "Yaw": headYawMean,
            "Pitch": headPitchMean,
            "Roll": headRollMean
          }
        };
      } catch (error) {
        console.error("Error in computeBasicStats:", error);
        return {};
      }
    }

    // Basic helper functions with error handling
    function mean(arr) {
      try {
        if (!Array.isArray(arr) || !arr.length) return 0;
        return arr.reduce((a, b) => a + b, 0) / arr.length;
      } catch (error) {
        console.error("Error in mean calculation:", error);
        return 0;
      }
    }

    function variance(arr) {
      try {
        if (!Array.isArray(arr) || !arr.length) return 0;
        const m = mean(arr);
        return mean(arr.map(x => (x - m) ** 2));
      } catch (error) {
        console.error("Error in variance calculation:", error);
        return 0;
      }
    }

    function standardDeviation(arr) {
      try {
        return Math.sqrt(variance(arr));
      } catch (error) {
        console.error("Error in standardDeviation calculation:", error);
        return 0;
      }
    }

    // Update the statistics display with error handling
    function updateBasicStats(stats) {
      try {
        const container = document.getElementById('basicStats');
        if (!container) return;
        
        container.innerHTML = '';
        for (const [key, value] of Object.entries(stats)) {
          const card = document.createElement('div');
          card.className = 'stat-card';
          if (typeof value === 'object') {
            let content = `<h3>${key}</h3>`;
            for (const [subKey, subValue] of Object.entries(value)) {
              content += `<p><strong>${subKey}:</strong> ${subValue}</p>`;
            }
            card.innerHTML = content;
          } else {
            card.innerHTML = `<h3>${key}</h3><p>${value}</p>`;
          }
          container.appendChild(card);
        }
      } catch (error) {
        console.error("Error in updateBasicStats:", error);
      }
    }

    // Create visualization charts with error handling
    function createEyeMovementChart(data) {
      try {
        const canvas = document.getElementById('eyeMovementChart');
        if (!canvas) {
          logMessage("Eye movement chart canvas not found", 'error');
          return;
        }

        const ctx = canvas.getContext('2d');
        
        // Safely destroy existing chart
        if (window.eyeMovementChart && typeof window.eyeMovementChart.destroy === 'function') {
          window.eyeMovementChart.destroy();
        }
        window.eyeMovementChart = null;

        const validData = data.filter(d =>
          ((d.x !== undefined && d.x !== '' && d.x !== null) || (d.docX !== undefined && d.docX !== '' && d.docX !== null)) &&
          ((d.y !== undefined && d.y !== '' && d.y !== null) || (d.docY !== undefined && d.docY !== '' && d.docY !== null)) &&
          d.timestamp
        );

        if (!validData.length) {
          logMessage("No valid data for eye movement chart", 'warning');
          return;
        }

        const points = validData.map(d => ({
          x: d.x !== undefined && d.x !== '' ? d.x : d.docX,
          y: d.y !== undefined && d.y !== '' ? d.y : d.docY,
          timestamp: new Date(d.timestamp).getTime()
        }));

        const startTime = points[0].timestamp;
        const endTime = points[points.length - 1].timestamp;

        points.forEach(p => {
          const progress = (p.timestamp - startTime) / (endTime - startTime);
          p.color = `hsl(${200 + progress * 160}, 70%, 50%)`;
        });

        window.eyeMovementChart = new Chart(ctx, {
          type: 'scatter',
          data: {
            datasets: [{
              label: 'Gaze Path',
              data: points,
              backgroundColor: points.map(p => p.color),
              pointRadius: 4,
              pointHoverRadius: 6
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                reverse: true,
                title: { display: true, text: 'Y Position (pixels)' }
              },
              x: {
                title: { display: true, text: 'X Position (pixels)' }
              }
            },
            plugins: {
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const point = context.raw;
                    return [
                      `Position: (${point.x.toFixed(1)}, ${point.y.toFixed(1)})`,
                      `Time: ${new Date(point.timestamp).toLocaleTimeString()}`
                    ];
                  }
                }
              }
            }
          }
        });
      } catch (error) {
        console.error("Error creating eye movement chart:", error);
        logMessage("Failed to create eye movement chart");
      }
    }

    function createPupilDilationChart(data) {
      try {
        const canvas = document.getElementById('pupilDilationChart');
        if (!canvas) {
          logMessage("Pupil dilation chart canvas not found", 'error');
          return;
        }

        const ctx = canvas.getContext('2d');
        
        // Safely destroy existing chart
        if (window.pupilDilationChart && typeof window.pupilDilationChart.destroy === 'function') {
          window.pupilDilationChart.destroy();
        }
        window.pupilDilationChart = null;

        const validData = data.filter(d => d.pupilD !== undefined && d.pupilD !== null && d.pupilD !== '' && d.timestamp);
        
        if (!validData.length) {
          logMessage("No valid data for pupil dilation chart", 'warning');
          return;
        }

        const timestamps = validData.map(d => new Date(d.timestamp));

        window.pupilDilationChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: timestamps,
            datasets: [{
              label: 'Pupil Diameter (mm)',
              data: validData.map(d => ({ x: new Date(d.timestamp), y: d.pupilD })),
              borderColor: 'rgba(75, 192, 192, 1)',
              backgroundColor: 'rgba(75, 192, 192, 0.2)',
              fill: true,
              tension: 0.4
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                type: 'time',
                time: { unit: 'second', displayFormats: { second: 'HH:mm:ss' } },
                title: { display: true, text: 'Time' }
              },
              y: {
                title: { display: true, text: 'Pupil Diameter (mm)' }
              }
            }
          }
        });
      } catch (error) {
        console.error("Error creating pupil dilation chart:", error);
        logMessage("Failed to create pupil dilation chart");
      }
    }

    function createHeadMovementChart(data) {
      try {
        const canvas = document.getElementById('headMovementChart');
        if (!canvas) {
          logMessage("Head movement chart canvas not found", 'error');
          return;
        }

        const ctx = canvas.getContext('2d');
        
        // Safely destroy existing chart
        if (window.headMovementChart && typeof window.headMovementChart.destroy === 'function') {
          window.headMovementChart.destroy();
        }
        window.headMovementChart = null;

        const validData = data.filter(d =>
          d.HeadX !== undefined && d.HeadY !== undefined && d.HeadZ !== undefined &&
          d.HeadX !== null && d.HeadY !== null && d.HeadZ !== null &&
          d.HeadX !== '' && d.HeadY !== '' && d.HeadZ !== '' && d.timestamp
        );

        if (!validData.length) {
          logMessage("No valid data for head movement chart", 'warning');
          return;
        }

        const timestamps = validData.map(d => new Date(d.timestamp));

        window.headMovementChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: timestamps,
            datasets: [
              {
                label: 'Head X',
                data: validData.map(d => ({ x: new Date(d.timestamp), y: d.HeadX })),
                borderColor: 'rgba(255, 99, 132, 1)',
                tension: 0.4
              },
              {
                label: 'Head Y',
                data: validData.map(d => ({ x: new Date(d.timestamp), y: d.HeadY })),
                borderColor: 'rgba(54, 162, 235, 1)',
                tension: 0.4
              },
              {
                label: 'Head Z',
                data: validData.map(d => ({ x: new Date(d.timestamp), y: d.HeadZ })),
                borderColor: 'rgba(75, 192, 192, 1)',
                tension: 0.4
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                type: 'time',
                time: { unit: 'second', displayFormats: { second: 'HH:mm:ss' } },
                title: { display: true, text: 'Time' }
              },
              y: {
                title: { display: true, text: 'Head Position' }
              }
            }
          }
        });
      } catch (error) {
        console.error("Error creating head movement chart:", error);
        logMessage("Failed to create head movement chart");
      }
    }

    // Process uploaded CSV file with enhanced error handling
    function processFile() {
      try {
        const fileInput = document.getElementById('csvFile');
        const file = fileInput.files[0];
        
        if (!file) {
          alert('Please select a CSV file first.');
          return;
        }

        Papa.parse(file, {
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true,
          complete: function(results) {
            try {
              if (results.errors.length > 0) {
                console.error('CSV parsing errors:', results.errors);
                alert('Error parsing CSV file. Please check the console for details.');
                return;
              }

              const data = results.data.filter(row => row.timestamp != null && row.timestamp !== '');
              
              if (data.length === 0) {
                alert('No valid data found in the CSV file.');
                return;
              }

              const stats = computeBasicStats(data);
              updateBasicStats(stats);
              createEyeMovementChart(data);
              createPupilDilationChart(data);
              createHeadMovementChart(data);
              
              logMessage(`Successfully processed ${data.length} data points`);
            } catch (error) {
              console.error("Error in Papa.parse complete callback:", error);
              alert('Error processing CSV data: ' + error.message);
            }
          },
          error: function(error) {
            console.error('Error parsing CSV:', error);
            alert('Failed to parse CSV file: ' + error.message);
          }
        });
      } catch (error) {
        console.error("Error in processFile:", error);
        alert('Error processing file: ' + error.message);
      }
    }

    // Add window error handler for uncaught errors
    window.onerror = function(message, source, lineno, colno, error) {
      console.error("Global error:", {message, source, lineno, colno, error});
      logMessage(`Uncaught error: ${message}`);
      return false;
    };

    // Add chart toggle functionality
    function toggleChart(chartId) {
      // Hide all charts
      document.querySelectorAll('.chart-container').forEach(container => {
        container.classList.remove('active');
      });
      
      // Deactivate all toggle buttons
      document.querySelectorAll('.chart-toggle').forEach(button => {
        button.classList.remove('active');
      });
      
      // Show selected chart and activate its toggle
      document.getElementById(chartId + 'Container').classList.add('active');
      document.getElementById(chartId + 'Toggle').classList.add('active');
    }
    
    // Initialize with eye movement chart visible
    window.addEventListener('load', function() {
      toggleChart('eyeMovement');
    });

    // Add window focus/blur handlers
    window.addEventListener('blur', function() {
      if (tracking) {
        logMessage("Window lost focus. Consider recalibrating if tracking accuracy decreases.", 'warning');
      }
    });

    // Add connection status check
    window.addEventListener('online', function() {
      logMessage("Internet connection restored.", 'success');
    });

    window.addEventListener('offline', function() {
      logMessage("Internet connection lost. Tracking may be affected.", 'error');
      if (tracking) {
        stopTracking();
      }
    });

    // Add beforeunload handler
    window.addEventListener('beforeunload', function(e) {
      if (tracking || recordedData.length > 0) {
        const message = "You have active tracking or unsaved data. Are you sure you want to leave?";
        e.returnValue = message;
        return message;
      }
    });
  </script>
</head>
<body>
  <div class="container">
    <h1>Eye Tracking Recorder & Analysis Dashboard</h1>
    
    <!-- LIVE TRACKING SECTION -->
    <section id="liveTrackingSection">
      <h2>Live Eye Tracking Recorder</h2>
      <div id="liveControls">
        <button type="button" onclick="startTracking()">Start Tracking</button>
        <button type="button" onclick="stopTracking()">Stop Tracking</button>
        <button type="button" onclick="exportCSV()">Export CSV</button>
        <button type="button" onclick="clearData()">Clear Data</button>
      </div>
      <div id="liveData">
        <em>Live gaze data will appear here...</em>
      </div>
      <div id="debugLog">
        <em>Debug log messages will appear here...</em>
      </div>
    </section>

    <hr>

    <!-- CSV ANALYSIS DASHBOARD SECTION -->
    <section id="analysisDashboardSection">
      <h2>CSV Data Analysis Dashboard</h2>
      <div class="file-input">
        <label for="csvFile">Select CSV File:</label>
        <input type="file" id="csvFile" accept=".csv" title="Upload gaze tracking data CSV file">
        <button type="button" onclick="processFile()">Analyze Data</button>
      </div>
      <div class="stats-container" id="basicStats"></div>
      <div class="chart-controls">
        <button type="button" id="eyeMovementToggle" class="chart-toggle red active" onclick="toggleChart('eyeMovement')">Eye Movement</button>
        <button type="button" id="pupilDilationToggle" class="chart-toggle green" onclick="toggleChart('pupilDilation')">Pupil Dilation</button>
        <button type="button" id="headMovementToggle" class="chart-toggle blue" onclick="toggleChart('headMovement')">Head Movement</button>
      </div>
      <div id="eyeMovementContainer" class="chart-container active">
        <h3>Eye Movement Trajectory</h3>
        <canvas id="eyeMovementChart"></canvas>
      </div>
      <div id="pupilDilationContainer" class="chart-container">
        <h3>Pupil Dilation Over Time</h3>
        <canvas id="pupilDilationChart"></canvas>
      </div>
      <div id="headMovementContainer" class="chart-container">
        <h3>Head Displacement Over Time</h3>
        <canvas id="headMovementChart"></canvas>
      </div>
    </section>
  </div>
</body>
</html>
