<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Eye Tracking Recorder & Analysis Dashboard</title>
  <!-- GazeCloudAPI for live tracking -->
  <script src="https://api.gazerecorder.com/GazeCloudAPI.js"></script>
  <!-- Chart.js for visualizations -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
  <!-- PapaParse for CSV processing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
  <style>
    :root {
      /* Light theme variables */
      --bg-primary: #f5f5f5;
      --bg-secondary: #ffffff;
      --text-primary: #333333;
      --text-secondary: #666666;
      --border-color: #dddddd;
      --shadow-color: rgba(0, 0, 0, 0.1);
      --accent-color: #4a90e2;
      --success-color: #2ecc71;
      --warning-color: #f1c40f;
      --error-color: #e74c3c;
      --chart-bg: rgba(255, 255, 255, 0.9);
      --notification-bg: rgba(255, 255, 255, 0.95);
    }

    [data-theme="dark"] {
      /* Dark theme variables */
      --bg-primary: #1a1a1a;
      --bg-secondary: #2d2d2d;
      --text-primary: #ffffff;
      --text-secondary: #cccccc;
      --border-color: #404040;
      --shadow-color: rgba(0, 0, 0, 0.3);
      --accent-color: #64b5f6;
      --success-color: #66bb6a;
      --warning-color: #ffd54f;
      --error-color: #ef5350;
      --chart-bg: rgba(45, 45, 45, 0.9);
      --notification-bg: rgba(45, 45, 45, 0.95);
    }

    /* Theme transition */
    * {
      transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
    }

    body {
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--bg-primary);
      color: var(--text-primary);
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
    }

    .theme-toggle {
      background: var(--bg-secondary);
      border: 2px solid var(--border-color);
      border-radius: 20px;
      padding: 5px 15px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.9em;
      color: var(--text-primary);
      transition: transform 0.2s ease;
    }

    .theme-toggle:hover {
      transform: scale(1.05);
    }

    .theme-toggle:active {
      transform: scale(0.95);
    }

    h1, h2, h3 {
      color: var(--text-primary);
      margin: 0;
    }

    hr {
      margin: 40px 0;
      border: none;
      border-top: 1px solid var(--border-color);
    }

    button {
      background: var(--bg-secondary);
      color: var(--text-primary);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      padding: 10px 20px;
      font-size: 1em;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    button:hover {
      background: var(--accent-color);
      color: white;
      border-color: var(--accent-color);
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    #liveData, #debugLog {
      background-color: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
      box-shadow: 0 2px 8px var(--shadow-color);
    }

    #liveData {
      min-height: 50px;
    }

    #debugLog {
      max-height: 200px;
      overflow-y: auto;
      font-family: 'Consolas', monospace;
      font-size: 0.9em;
      white-space: pre-wrap;
    }

    .file-input, .stats-container, .chart-container {
      background: var(--bg-secondary);
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 12px var(--shadow-color);
      margin-bottom: 30px;
      border: 1px solid var(--border-color);
    }

    .stats-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
    }

    .stat-card {
      background: var(--bg-secondary);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 6px var(--shadow-color);
      border: 1px solid var(--border-color);
    }

    .chart-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      justify-content: center;
    }

    .chart-toggle {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      opacity: 0.7;
    }

    .chart-toggle.active {
      opacity: 1;
      transform: scale(1.05);
      box-shadow: 0 4px 12px var(--shadow-color);
    }

    /* Notification system */
    .notification-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }

    .notification {
      background: var(--notification-bg);
      color: var(--text-primary);
      padding: 15px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px var(--shadow-color);
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      pointer-events: auto;
      animation: slideIn 0.3s ease forwards;
      max-width: 300px;
      border-left: 4px solid var(--accent-color);
    }

    .notification.success { border-color: var(--success-color); }
    .notification.warning { border-color: var(--warning-color); }
    .notification.error { border-color: var(--error-color); }

    .notification.fade-out {
      animation: slideOut 0.3s ease forwards;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* Chart theme adaptations */
    .chart-container {
      background: var(--chart-bg);
    }

    canvas {
      border-radius: 8px;
    }

    .live-data-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      padding: 15px;
      background: var(--bg-secondary);
      border-radius: 8px;
      box-shadow: 0 2px 8px var(--shadow-color);
    }
    
    .data-section {
      padding: 10px;
      border-left: 3px solid var(--accent-color);
    }
    
    .data-value {
      font-family: 'Consolas', monospace;
      font-weight: 600;
      color: var(--text-primary);
    }
    
    .data-value.good { color: var(--success-color); }
    .data-value.poor { color: var(--error-color); }
    .data-value.calibrating { color: var(--warning-color); }
    .data-value.recording { color: var(--success-color); }
    .data-value.idle { color: var(--text-secondary); }
    
    #liveData {
      margin: 20px 0;
      transition: all 0.3s ease;
    }

    .calibration-message {
      background: var(--bg-secondary);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px var(--shadow-color);
      margin: 20px 0;
      border-left: 4px solid var(--accent-color);
    }
    
    .calibration-message.error {
      border-left-color: var(--error-color);
    }
    
    .calibration-message h3 {
      margin: 0 0 15px 0;
      color: var(--text-primary);
    }
    
    .calibration-message ol,
    .calibration-message ul {
      margin: 10px 0;
      padding-left: 25px;
    }
    
    .calibration-message li {
      margin: 8px 0;
      color: var(--text-secondary);
    }

    .initialization-steps {
      margin: 15px 0;
    }
    
    .step {
      display: flex;
      align-items: center;
      margin: 10px 0;
      gap: 10px;
    }
    
    .step-indicator {
      font-size: 1.2em;
    }
    
    .calibration-progress {
      margin: 20px 0;
    }
    
    .progress-bar {
      height: 6px;
      background: var(--border-color);
      border-radius: 3px;
      overflow: hidden;
    }
    
    .progress-indicator {
      height: 100%;
      background: var(--accent-color);
      width: 0%;
      animation: progress 30s linear;
    }
    
    @keyframes progress {
      from { width: 0%; }
      to { width: 100%; }
    }
    
    .calibration-message ol li {
      opacity: 0.6;
      transition: opacity 0.3s ease;
    }
    
    .calibration-message ol li.active {
      opacity: 1;
      color: var(--text-primary);
      font-weight: 600;
    }

    .sessions-container {
      background: var(--bg-secondary);
      padding: 20px;
      border-radius: 12px;
      margin: 20px 0;
      box-shadow: 0 4px 12px var(--shadow-color);
    }

    .session-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      margin: 10px 0;
      background: var(--bg-primary);
      border-radius: 8px;
      border: 1px solid var(--border-color);
    }

    .session-info {
      display: flex;
      gap: 20px;
      align-items: center;
    }

    .session-actions {
      display: flex;
      gap: 10px;
    }

    .session-actions button {
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
    }

    .chart-container {
      background: var(--bg-secondary);
      border-radius: 8px;
      padding: 15px;
      margin: 20px 0;
      box-shadow: 0 2px 8px var(--shadow-color);
      height: 300px;
    }

    .chart-container canvas {
      width: 100% !important;
      height: 100% !important;
    }
  </style>
  <script>
    /********** LIVE EYE TRACKING SECTION **********/
    let recordedData = [];
    let tracking = false;
    let lastUpdate = 0;
    let calibrationAttempts = 0;
    let isCalibrating = false;
    let dataCollectionReady = false;
    let lastDataPoint = null;
    const UPDATE_INTERVAL = 50; // ms
    const MAX_RECORDED_POINTS = 10000;
    const MAX_CALIBRATION_ATTEMPTS = 3;
    const CALIBRATION_TIMEOUT = 30000; // 30 seconds
    const MIN_DATA_INTERVAL = 16; // Minimum interval between data points (ms)
    const DATA_QUALITY_THRESHOLD = 0.6; // Minimum confidence threshold

    // Add database handling code after the existing variables
    const DB_NAME = 'EyeTrackingDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'sessions';
    let db;

    // Initialize database
    function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onerror = (event) => {
          logMessage("Database error: " + event.target.error, 'error');
          reject(event.target.error);
        };
        
        request.onsuccess = (event) => {
          db = event.target.result;
          logMessage("Database initialized successfully", 'success');
          resolve(db);
        };
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            const store = db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
            store.createIndex('timestamp', 'timestamp', { unique: false });
            store.createIndex('duration', 'duration', { unique: false });
            logMessage("Database structure created", 'info');
          }
        };
      });
    }

    // Save session data to database
    function saveSessionToDB(sessionData) {
      return new Promise((resolve, reject) => {
        if (!db) {
          reject(new Error("Database not initialized"));
          return;
        }

        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        
        const session = {
          timestamp: new Date().toISOString(),
          duration: sessionData.length > 0 ? 
            (sessionData[sessionData.length - 1].timestamp - sessionData[0].timestamp) / 1000 : 0,
          dataPoints: sessionData.length,
          averageConfidence: mean(sessionData.map(d => d.confidence || 0)),
          data: sessionData
        };

        const request = store.add(session);
        
        request.onsuccess = () => {
          logMessage(`Session saved to database (${session.dataPoints} points)`, 'success');
          resolve(request.result);
        };
        
        request.onerror = () => {
          logMessage("Error saving session to database", 'error');
          reject(request.error);
        };
      });
    }

    // Load sessions from database
    function loadSessions() {
      return new Promise((resolve, reject) => {
        if (!db) {
          reject(new Error("Database not initialized"));
          return;
        }

        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.getAll();

        request.onsuccess = () => {
          const sessions = request.result;
          updateSessionsList(sessions);
          resolve(sessions);
        };

        request.onerror = () => {
          logMessage("Error loading sessions from database", 'error');
          reject(request.error);
        };
      });
    }

    // Update sessions list in UI
    function updateSessionsList(sessions) {
      const sessionsList = document.getElementById('sessionsList');
      if (!sessionsList) return;

      sessionsList.innerHTML = '';
      sessions.forEach(session => {
        const sessionElement = document.createElement('div');
        sessionElement.className = 'session-item';
        sessionElement.innerHTML = `
          <div class="session-info">
            <strong>Session ${session.id}</strong>
            <span>Date: ${new Date(session.timestamp).toLocaleString()}</span>
            <span>Duration: ${session.duration.toFixed(1)}s</span>
            <span>Points: ${session.dataPoints}</span>
            <span>Confidence: ${(session.averageConfidence * 100).toFixed(1)}%</span>
          </div>
          <div class="session-actions">
            <button onclick="loadSessionData(${session.id})">View</button>
            <button onclick="exportSessionData(${session.id})">Export</button>
            <button onclick="deleteSession(${session.id})">Delete</button>
          </div>
        `;
        sessionsList.appendChild(sessionElement);
      });
    }

    // Load specific session data
    function loadSessionData(sessionId) {
      const transaction = db.transaction([STORE_NAME], 'readonly');
      const store = transaction.objectStore(STORE_NAME);
      const request = store.get(sessionId);

      request.onsuccess = () => {
        const session = request.result;
        if (session) {
          // Update charts with session data
          createEyeMovementChart(session.data);
          createPupilDilationChart(session.data);
          createHeadMovementChart(session.data);
          // Update stats
          const stats = computeBasicStats(session.data);
          updateBasicStats(stats);
          logMessage(`Loaded session ${sessionId} data`, 'success');
        }
      };

      request.onerror = () => {
        logMessage(`Error loading session ${sessionId}`, 'error');
      };
    }

    // Export specific session data
    function exportSessionData(sessionId) {
      const transaction = db.transaction([STORE_NAME], 'readonly');
      const store = transaction.objectStore(STORE_NAME);
      const request = store.get(sessionId);

      request.onsuccess = () => {
        const session = request.result;
        if (session) {
          const csvContent = "data:text/csv;charset=utf-8,";
          // Add headers
          csvContent += "timestamp,x,y,state,confidence,pupilD,HeadX,HeadY,HeadZ,HeadYaw,HeadPitch,HeadRoll\n";
          
          // Add data rows
          session.data.forEach(data => {
            const row = [
              data.timestamp,
              data.x || '',
              data.y || '',
              data.state || '',
              data.confidence || '',
              data.pupilD || '',
              data.HeadX || '',
              data.HeadY || '',
              data.HeadZ || '',
              data.HeadYaw || '',
              data.HeadPitch || '',
              data.HeadRoll || ''
            ].join(',');
            csvContent += row + "\n";
          });

          const encodedUri = encodeURI(csvContent);
          const link = document.createElement("a");
          link.setAttribute("href", encodedUri);
          link.setAttribute("download", `eye_tracking_session_${sessionId}_${new Date().toISOString()}.csv`);
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          logMessage(`Exported session ${sessionId} data`, 'success');
        }
      };

      request.onerror = () => {
        logMessage(`Error exporting session ${sessionId}`, 'error');
      };
    }

    // Delete specific session
    function deleteSession(sessionId) {
      if (!confirm('Are you sure you want to delete this session?')) return;

      const transaction = db.transaction([STORE_NAME], 'readwrite');
      const store = transaction.objectStore(STORE_NAME);
      const request = store.delete(sessionId);

      request.onsuccess = () => {
        logMessage(`Deleted session ${sessionId}`, 'success');
        loadSessions(); // Refresh the sessions list
      };

      request.onerror = () => {
        logMessage(`Error deleting session ${sessionId}`, 'error');
      };
    }

    // Update UI state
    function updateUIState(isRecording) {
      try {
        const startBtn = document.querySelector('button[onclick="startTracking()"]');
        const stopBtn = document.querySelector('button[onclick="stopTracking()"]');
        const exportBtn = document.querySelector('button[onclick="exportCSV()"]');
        const clearBtn = document.querySelector('button[onclick="clearData()"]');
        
        if (startBtn) startBtn.disabled = isRecording;
        if (stopBtn) stopBtn.disabled = !isRecording;
        if (exportBtn) exportBtn.disabled = !recordedData.length;
        if (clearBtn) clearBtn.disabled = !recordedData.length;
      } catch (error) {
        console.error("Error updating UI state:", error);
      }
    }

    // Enhanced logging with severity levels
    function logMessage(message, level = 'info') {
      try {
        const logDiv = document.getElementById("debugLog");
        const timestamp = new Date().toLocaleTimeString();
        const logLevels = {
          error: '🔴',
          warning: '🟡',
          success: '🟢',
          info: 'ℹ️'
        };
        const logEntry = `[${timestamp}] ${logLevels[level] || 'ℹ️'} ${message}\n`;
        
        logDiv.textContent += logEntry;
        logDiv.scrollTop = logDiv.scrollHeight;
        
        // Console logging with appropriate methods
        switch(level) {
          case 'error':
            console.error(message);
            break;
          case 'warning':
            console.warn(message);
            break;
          default:
            console.log(message);
        }
      } catch (error) {
        console.error("Error in logMessage:", error);
      }
    }

    // Update the live data display with the most recent gaze values
    function updateLiveData(data) {
      try {
        const now = Date.now();
        if (now - lastUpdate < UPDATE_INTERVAL) return;
        lastUpdate = now;

        const liveDiv = document.getElementById("liveData");
        if (!liveDiv) return;

        // Create a more detailed live data display
        liveDiv.innerHTML = `
          <div class="live-data-grid">
            <div class="data-section">
              <strong>Gaze Data:</strong><br>
              State: <span class="data-value">${data.state || 'N/A'}</span><br>
              X: <span class="data-value">${(data.docX || data.x || 0).toFixed(2)}</span><br>
              Y: <span class="data-value">${(data.docY || data.y || 0).toFixed(2)}</span><br>
              Confidence: <span class="data-value ${(data.confidence || 0) > DATA_QUALITY_THRESHOLD ? 'good' : 'poor'}">${((data.confidence || 0) * 100).toFixed(1)}%</span>
            </div>
            <div class="data-section">
              <strong>Head Position:</strong><br>
              X: <span class="data-value">${(data.HeadX || 0).toFixed(2)}</span><br>
              Y: <span class="data-value">${(data.HeadY || 0).toFixed(2)}</span><br>
              Z: <span class="data-value">${(data.HeadZ || 0).toFixed(2)}</span>
            </div>
            <div class="data-section">
              <strong>Session Info:</strong><br>
              Points: <span class="data-value">${recordedData.length}</span><br>
              Duration: <span class="data-value">${((now - recordedData[0]?.timestamp || now) / 1000).toFixed(1)}s</span><br>
              Status: <span class="data-value ${isCalibrating ? 'calibrating' : (tracking ? 'recording' : 'idle')}">${isCalibrating ? 'Calibrating...' : (tracking ? 'Recording' : 'Idle')}</span>
            </div>
          </div>
        `;
      } catch (error) {
        console.error("Error in updateLiveData:", error);
      }
    }

    // Theme management
    function initializeTheme() {
      const currentTheme = localStorage.getItem('theme') || 'light';
      document.documentElement.setAttribute('data-theme', currentTheme);
      
      const themeToggle = document.createElement('button');
      themeToggle.className = 'theme-toggle';
      themeToggle.innerHTML = currentTheme === 'light' ? '🌙 Dark Mode' : '☀️ Light Mode';
      themeToggle.onclick = toggleTheme;
      
      document.querySelector('.header').appendChild(themeToggle);
    }
    
    function toggleTheme() {
      const currentTheme = document.documentElement.getAttribute('data-theme');
      const newTheme = currentTheme === 'light' ? 'dark' : 'light';
      
      document.documentElement.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme);
      
      const themeToggle = document.querySelector('.theme-toggle');
      themeToggle.innerHTML = newTheme === 'light' ? '🌙 Dark Mode' : '☀️ Light Mode';
      
      // Update chart themes if they exist
      updateChartThemes();
    }
    
    function updateChartThemes() {
      const charts = [window.eyeMovementChart, window.pupilDilationChart, window.headMovementChart];
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      
      charts.forEach(chart => {
        if (chart && chart.options) {
          chart.options.scales.x.grid.color = isDark ? '#404040' : '#dddddd';
          chart.options.scales.y.grid.color = isDark ? '#404040' : '#dddddd';
          chart.options.scales.x.ticks.color = isDark ? '#cccccc' : '#666666';
          chart.options.scales.y.ticks.color = isDark ? '#cccccc' : '#666666';
          chart.update();
        }
      });
    }

    // Add the resetDataStructures function before it's used
    function resetDataStructures() {
      try {
        // Clear recorded data array
        recordedData = [];
        
        // Reset state variables
        tracking = false;
        isCalibrating = false;
        lastUpdate = 0;
        lastDataPoint = null;
        
        // Safely destroy existing charts
        const charts = {
          eyeMovementChart: window.eyeMovementChart,
          pupilDilationChart: window.pupilDilationChart,
          headMovementChart: window.headMovementChart
        };
        
        for (const [name, chart] of Object.entries(charts)) {
          if (chart && typeof chart.destroy === 'function') {
            try {
              chart.destroy();
              window[name] = null;
            } catch (chartError) {
              console.error(`Error destroying ${name}:`, chartError);
            }
          }
        }

        // Clear canvas contexts
        ['eyeMovementChart', 'pupilDilationChart', 'headMovementChart'].forEach(canvasId => {
          const canvas = document.getElementById(canvasId);
          if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
          }
        });

        // Reset UI elements
        document.getElementById("liveData").innerHTML = "<em>Live gaze data will appear here...</em>";
        
        // Update UI state
        updateUIState(false);
        
        logMessage("Data structures reset successfully", 'success');
      } catch (error) {
        console.error("Error in resetDataStructures:", error);
        logMessage("Error resetting data structures: " + error.message, 'error');
        throw error; // Re-throw to be caught by the calling function
      }
    }

    // Add API verification states
    const API_STATES = {
      INITIALIZING: 'initializing',
      CONNECTING: 'connecting',
      CONNECTED: 'connected',
      CALIBRATING: 'calibrating',
      RECORDING: 'recording',
      ERROR: 'error'
    };
    let apiState = API_STATES.INITIALIZING;
    let calibrationStartTime = 0;

    // Add debug mode and detailed error tracking
    const DEBUG = true;
    const ERROR_CODES = {
      API_NOT_FOUND: 'API_NOT_FOUND',
      API_LOAD_TIMEOUT: 'API_LOAD_TIMEOUT',
      WEBSOCKET_ERROR: 'WEBSOCKET_ERROR',
      CAMERA_DENIED: 'CAMERA_DENIED',
      INITIALIZATION_ERROR: 'INITIALIZATION_ERROR',
      CALIBRATION_ERROR: 'CALIBRATION_ERROR',
      CONNECTION_ERROR: 'CONNECTION_ERROR'
    };

    // Enhanced error logging
    function debugLog(message, data = null) {
      if (!DEBUG) return;
      const timestamp = new Date().toISOString();
      console.log(`[${timestamp}] Debug:`, message);
      if (data) console.log('Debug data:', data);
      logMessage(`🔍 Debug: ${message}`, 'info');
    }

    // Enhanced API verification with detailed checks
    function verifyGazeCloudAPI() {
      return new Promise((resolve, reject) => {
        debugLog('Starting GazeCloud API verification');
        
        // Check if script is loaded
        const gazeScript = document.querySelector('script[src*="GazeCloudAPI.js"]');
        if (!gazeScript) {
          debugLog('GazeCloud API script tag not found');
          reject({ code: ERROR_CODES.API_NOT_FOUND, message: 'GazeCloud API script not found in DOM' });
          return;
        }

        // Verify API object
        if (typeof GazeCloudAPI === 'undefined') {
          debugLog('GazeCloud API object not defined');
          reject({ code: ERROR_CODES.API_NOT_FOUND, message: 'GazeCloud API not found. Please check your internet connection.' });
          return;
        }

        // Verify required methods with detailed logging
        const requiredMethods = [
          'StartEyeTracking',
          'StopEyeTracking',
          'OnResult',
          'OnCalibrationComplete',
          'OnCalibrationFail',
          'OnCamDenied',
          'OnError'
        ];

        const missingMethods = requiredMethods.filter(method => {
          const exists = typeof GazeCloudAPI[method] === 'function';
          debugLog(`Checking method ${method}: ${exists ? 'Found' : 'Missing'}`);
          return !exists;
        });
        
        if (missingMethods.length > 0) {
          reject({
            code: ERROR_CODES.INITIALIZATION_ERROR,
            message: `Missing required GazeCloud API methods: ${missingMethods.join(', ')}`
          });
          return;
        }

        // Verify WebSocket support
        if (!window.WebSocket) {
          reject({
            code: ERROR_CODES.WEBSOCKET_ERROR,
            message: 'WebSocket support not available in browser'
          });
          return;
        }

        debugLog('API verification completed successfully');
        resolve(true);
      });
    }

    // Enhanced initialization with better error handling
    function initializeDataCollection() {
      debugLog('Starting data collection initialization');
      
      try {
        dataCollectionReady = false;
        recordedData = [];
        lastDataPoint = null;
        apiState = API_STATES.INITIALIZING;
        
        return verifyGazeCloudAPI()
          .then(() => {
            debugLog('API verified, resetting data structures');
            resetDataStructures();

            debugLog('Configuring GazeCloud API settings');
            
            // Configure with validation
            const config = {
              CalibrationType: 5, // 5-point calibration
              ShowVideo: true,
              UseClickRecalibration: true,
              Debug: DEBUG,
              GazeFlowContainer: 'liveData', // Specify container for calibration UI
              VideoElementContainer: 'liveData', // Specify container for video feed
              CallbackTrackingReady: function() {
                debugLog('Tracking ready callback triggered');
                logMessage("✅ Eye tracking system ready", 'success');
              },
              CallbackCalibrationFailed: function(error) {
                debugLog('Calibration failed callback', error);
                handleCalibrationFailure();
              }
            };

            Object.entries(config).forEach(([key, value]) => {
              try {
                GazeCloudAPI[key] = value;
                debugLog(`Set ${key} = ${value}`);
              } catch (error) {
                debugLog(`Error setting ${key}`, error);
              }
            });

            // Enhanced callback setup with debugging
            GazeCloudAPI.OnCalibrationComplete = function() {
              debugLog('Calibration completed');
              apiState = API_STATES.RECORDING;
              isCalibrating = false;
              tracking = true;
              calibrationAttempts = 0;
              logMessage("✅ Calibration completed successfully!", 'success');
              updateCalibrationUI('complete');
              updateUIState(true);
            };

            GazeCloudAPI.OnCalibrationFail = function() {
              debugLog('Calibration failed');
              apiState = API_STATES.ERROR;
              handleCalibrationFailure();
            };

            GazeCloudAPI.OnCamDenied = function() {
              debugLog('Camera access denied');
              apiState = API_STATES.ERROR;
              handleGazeError({
                code: ERROR_CODES.CAMERA_DENIED,
                message: "❌ Camera access denied. Please check your camera permissions."
              });
              updateUIState(false);
            };

            GazeCloudAPI.OnError = function(error) {
              debugLog('GazeCloud API error received:', error);
              
              let errorMessage = "Unknown GazeCloud API Error";
              let errorCode = ERROR_CODES.INITIALIZATION_ERROR;
              
              try {
                // Handle different error formats
                if (typeof error === 'object') {
                  if (error instanceof Error) {
                    errorMessage = error.message;
                  } else if (error !== null) {
                    errorMessage = JSON.stringify(error, Object.getOwnPropertyNames(error));
                  }
                } else if (typeof error === 'string') {
                  errorMessage = error;
                }
                
                // Determine error type
                if (errorMessage.toLowerCase().includes('camera')) {
                  errorCode = ERROR_CODES.CAMERA_DENIED;
                } else if (errorMessage.toLowerCase().includes('connection') || 
                          errorMessage.toLowerCase().includes('websocket')) {
                  errorCode = ERROR_CODES.CONNECTION_ERROR;
                }
                
                debugLog('Processed error:', { code: errorCode, message: errorMessage });
              } catch (e) {
                console.error('Error processing GazeCloud error:', e);
                errorMessage = "Failed to process error details";
              }
              
              handleGazeError({
                code: errorCode,
                message: `GazeCloud API Error: ${errorMessage}`,
                originalError: error
              });
            };

            GazeCloudAPI.OnConnect = function() {
              debugLog('GazeCloud API connected');
              apiState = API_STATES.CONNECTED;
              logMessage("✅ GazeCloud API connected successfully", 'success');
              updateConnectionUI('connected');
              dataCollectionReady = true;
            };

            GazeCloudAPI.OnResult = function(GazeData) {
              if (apiState === API_STATES.RECORDING) {
                handleGazeData(GazeData);
              }
            };

            GazeCloudAPI.OnCalibrationStart = function() {
              debugLog('Calibration started');
              apiState = API_STATES.CALIBRATING;
              calibrationStartTime = Date.now();
              isCalibrating = true;
              logMessage("🎯 Starting calibration process...", 'info');
              updateCalibrationUI('start');
            };

            debugLog('Data collection system initialized');
            dataCollectionReady = true;
            logMessage("✅ Data collection system initialized successfully", 'success');
            return true;
          })
          .catch(error => {
            debugLog('Initialization failed', error);
            logMessage(`❌ API Initialization failed: ${error.message}`, 'error');
            return false;
          });
      } catch (error) {
        debugLog('Fatal initialization error', error);
        console.error("Error initializing data collection:", error);
        logMessage("❌ Failed to initialize data collection: " + error.message, 'error');
        return false;
      }
    }

    // Update UI based on calibration state
    function updateCalibrationUI(state) {
      const liveData = document.getElementById("liveData");
      switch(state) {
        case 'start':
          liveData.innerHTML = `
            <div class="calibration-message">
              <h3>🎯 Calibration in Progress</h3>
              <p>Please follow these steps:</p>
              <ol>
                <li class="active">Look at each calibration point as it appears</li>
                <li>Keep your head still during calibration</li>
                <li>Follow the point with your eyes only</li>
                <li>Wait for all points to be completed</li>
              </ol>
              <div class="calibration-progress">
                <div class="progress-bar">
                  <div class="progress-indicator"></div>
                </div>
              </div>
            </div>
          `;
          break;
        case 'complete':
          liveData.innerHTML = `
            <div class="calibration-message success">
              <h3>✅ Calibration Complete</h3>
              <p>Eye tracking is now active and recording data.</p>
              <div class="live-data-grid">
                <div class="data-section">
                  <strong>Status:</strong>
                  <span class="data-value recording">Recording</span>
                </div>
              </div>
            </div>
          `;
          break;
      }
    }

    // Update UI based on connection state
    function updateConnectionUI(state) {
      const liveData = document.getElementById("liveData");
      switch(state) {
        case 'connecting':
          liveData.innerHTML = `
            <div class="calibration-message">
              <h3>🔄 Connecting to GazeCloud</h3>
              <div class="initialization-steps">
                <div class="step">
                  <span class="step-indicator">⚙️</span>
                  <span class="step-text">Establishing connection...</span>
                </div>
              </div>
              <div class="progress-bar">
                <div class="progress-indicator"></div>
              </div>
            </div>
          `;
          break;
        case 'connected':
          liveData.innerHTML = `
            <div class="calibration-message success">
              <h3>✅ Connected Successfully</h3>
              <p>Preparing for calibration...</p>
            </div>
          `;
          break;
      }
    }

    // Enhanced check for GazeCloud API with connection validation
    function checkGazeCloudAPI() {
      return new Promise((resolve, reject) => {
        let attempts = 0;
        const maxAttempts = 20; // Increased max attempts
        const checkInterval = 1000; // Increased interval to 1 second
        
        function check() {
          debugLog(`Checking GazeCloud API (attempt ${attempts + 1}/${maxAttempts})`);
          
          try {
            // First check if script is loaded
            const gazeScript = document.querySelector('script[src*="GazeCloudAPI.js"]');
            if (!gazeScript) {
              // If script is not found, inject it
              const script = document.createElement('script');
              script.src = 'https://api.gazerecorder.com/GazeCloudAPI.js';
              script.async = true;
              document.head.appendChild(script);
              debugLog('Injected GazeCloud API script');
            }

            if (typeof GazeCloudAPI !== 'undefined' && 
                GazeCloudAPI.StartEyeTracking && 
                typeof GazeCloudAPI.StartEyeTracking === 'function') {
              
              // Additional connection validation
              if (window.WebSocket) {
                apiState = API_STATES.CONNECTED;
                logMessage("✅ GazeCloud API loaded successfully", 'success');
                resolve(true);
                return;
              } else {
                reject(new Error("❌ WebSocket support not available"));
                return;
              }
            }
            
            attempts++;
            if (attempts >= maxAttempts) {
              reject(new Error("❌ GazeCloud API failed to load after multiple attempts"));
              return;
            }
            
            logMessage(`⏳ Waiting for GazeCloud API to load (attempt ${attempts}/${maxAttempts})...`, 'info');
            setTimeout(check, checkInterval);
          } catch (error) {
            reject(new Error("❌ Error checking GazeCloud API: " + error.message));
          }
        }
        
        check();
      });
    }

    // Add DataStorageService class definition
    class DataStorageService {
      constructor() {
        this.currentSession = {
          config: null,
          gazeData: []
        };
        this.sessionStartTime = 0;
        this.lastFixationStart = 0;
        this.lastGazePoint = null;
        this.fixationCount = 0;
        this.totalFixationDuration = 0;
        this.saccadeCount = 0;
        this.totalSaccadeLength = 0;
        this.blinkCount = 0;
        this.lastBlinkTime = 0;
      }

      initializeSession(config) {
        this.currentSession = {
          config,
          gazeData: []
        };
        this.sessionStartTime = Date.now();
        this.lastFixationStart = 0;
        this.lastGazePoint = null;
        this.fixationCount = 0;
        this.totalFixationDuration = 0;
        this.saccadeCount = 0;
        this.totalSaccadeLength = 0;
        this.blinkCount = 0;
        this.lastBlinkTime = Date.now();
      }

      addGazeData(data) {
        if (!this.currentSession.config) {
          throw new Error('No active session');
        }
        const enrichedData = this.calculateMetrics(data);
        this.currentSession.gazeData.push(enrichedData);
        this.lastGazePoint = enrichedData;
        return enrichedData;
      }

      getCurrentSession() {
        return this.currentSession;
      }

      clearSession() {
        this.currentSession = {
          config: null,
          gazeData: []
        };
        this.sessionStartTime = 0;
        this.lastFixationStart = 0;
        this.lastGazePoint = null;
        this.fixationCount = 0;
        this.totalFixationDuration = 0;
        this.saccadeCount = 0;
        this.totalSaccadeLength = 0;
        this.blinkCount = 0;
        this.lastBlinkTime = 0;
      }

      getGazeDataCount() {
        return this.currentSession.gazeData.length;
      }

      formatTime(timestamp) {
        const date = new Date(timestamp);
        return {
          formattedTime: date.toTimeString().split(' ')[0] + '.' + String(date.getMilliseconds()).padStart(3, '0'),
          formattedDate: date.toISOString().split('T')[0]
        };
      }

      formatSessionTime(sessionTime) {
        const minutes = Math.floor(sessionTime / 60000);
        const seconds = Math.floor((sessionTime % 60000) / 1000);
        const milliseconds = sessionTime % 1000;
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
      }

      calculateMetrics(data) {
        const now = Date.now();
        const enrichedData = { ...data };
        const sessionTime = now - this.sessionStartTime;
        const { formattedTime, formattedDate } = this.formatTime(now);

        // Add timestamps
        enrichedData.timestamp = now;
        enrichedData.sessionTime = sessionTime;
        enrichedData.formattedTime = formattedTime;
        enrichedData.formattedDate = formattedDate;
        enrichedData.sessionTimeFormatted = this.formatSessionTime(sessionTime);

        // Calculate fixation and saccade metrics
        if (this.lastGazePoint) {
          const distance = Math.sqrt(
            Math.pow((data.x - this.lastGazePoint.x), 2) + 
            Math.pow((data.y - this.lastGazePoint.y), 2)
          );

          const FIXATION_THRESHOLD = 30;
          if (distance < FIXATION_THRESHOLD) {
            const fixationDuration = now - this.lastFixationStart;
            enrichedData.fixationDuration = fixationDuration;
            this.totalFixationDuration += fixationDuration;
            
            if (!this.lastGazePoint.fixationDuration) {
              this.fixationCount++;
            }
          } else {
            this.lastFixationStart = now;
            enrichedData.saccadeLength = distance;
            this.saccadeCount++;
            this.totalSaccadeLength += distance;
          }

          enrichedData.gazeDistance = distance;
          
          // Calculate velocities
          const timeElapsed = now - this.lastGazePoint.timestamp;
          enrichedData.gazeVelocity = distance / (timeElapsed / 1000); // pixels per second
        } else {
          this.lastFixationStart = now;
        }

        // Detect blinks
        if (data.confidence && data.confidence < 0.1) {
          if (now - this.lastBlinkTime > 300) {
            this.blinkCount++;
            this.lastBlinkTime = now;
          }
        }

        // Calculate aggregate metrics
        const sessionDuration = Math.max((now - this.sessionStartTime) / 1000 / 60, 1/60);
        enrichedData.blinkRate = this.blinkCount / sessionDuration;
        enrichedData.avgFixationDuration = this.totalFixationDuration / Math.max(this.fixationCount, 1);
        enrichedData.fixationsPerMinute = this.fixationCount / sessionDuration;
        enrichedData.avgSaccadeLength = this.totalSaccadeLength / Math.max(this.saccadeCount, 1);
        enrichedData.saccadesPerMinute = this.saccadeCount / sessionDuration;

        return enrichedData;
      }
    }

    // Initialize DataStorageService instance
    let dataStorage = new DataStorageService();

    // Update handleGazeData function to use DataStorageService
    function handleGazeData(GazeData) {
      try {
        if (!tracking || !dataCollectionReady) return;

        const processedData = processGazeData(GazeData);
        if (!processedData) return;

        // Add data to storage service
        const enrichedData = dataStorage.addGazeData(processedData);
        
        // Update UI with enriched data
        updateLiveData(enrichedData);
        
        if (dataStorage.getGazeDataCount() % 50 === 0) {
          const recentData = dataStorage.getCurrentSession().gazeData.slice(-50);
          const avgConfidence = mean(recentData.map(d => d.confidence || 0));
          logMessage(
            `Recording active: ${dataStorage.getGazeDataCount()} points collected | ` +
            `Recent Quality: ${(avgConfidence * 100).toFixed(1)}% | ` +
            `Rate: ${(50000 / (Date.now() - lastUpdate)).toFixed(1)} Hz`,
            avgConfidence > DATA_QUALITY_THRESHOLD ? 'success' : 'warning'
          );
        }
      } catch (error) {
        console.error("Error processing gaze data:", error);
        logMessage("Error processing gaze data: " + error.message, 'error');
      }
    }

    // Update startTracking function to initialize session
    function startTracking() {
      try {
        if (tracking) {
          stopTracking();
          return;
        }

        if (calibrationAttempts >= MAX_CALIBRATION_ATTEMPTS) {
          logMessage(`❌ Too many calibration attempts. Please refresh the page and try again.`, 'error');
          return;
        }

        // Initialize new session
        dataStorage.initializeSession({
          participantId: 'P' + Date.now(),
          isPilot: false
        });

        apiState = API_STATES.INITIALIZING;
        updateConnectionUI('connecting');

        // Clear any existing video elements
        document.querySelectorAll('video').forEach(video => video.remove());

        // Initialize GazeCloud API and start tracking
        if (!initializeGazeTracking()) {
          throw new Error("Failed to initialize gaze tracking");
        }

        try {
          GazeCloudAPI.StartEyeTracking();
          logMessage("🎯 Starting eye tracking system...", 'info');
          calibrationAttempts++;
        } catch (error) {
          throw new Error("Failed to start eye tracking: " + error.message);
        }

      } catch (error) {
        apiState = API_STATES.ERROR;
        console.error("Error in startTracking:", error);
        handleGazeError({
          code: ERROR_CODES.INITIALIZATION_ERROR,
          message: "Failed to start tracking: " + error.message
        });
      }
    }

    // Update stopTracking function to handle session data
    function stopTracking() {
      try {
        if (!tracking) return;
        
        GazeCloudAPI.StopEyeTracking();
        tracking = false;
        isCalibrating = false;
        
        // Save session data to IndexedDB
        const session = dataStorage.getCurrentSession();
        if (session && session.gazeData.length > 0) {
          const transaction = db.transaction([STORE_NAME], 'readwrite');
          const store = transaction.objectStore(STORE_NAME);
          
          const sessionData = {
            timestamp: new Date().toISOString(),
            duration: session.gazeData.length > 0 ? 
              (session.gazeData[session.gazeData.length - 1].timestamp - session.gazeData[0].timestamp) / 1000 : 0,
            dataPoints: session.gazeData.length,
            averageConfidence: mean(session.gazeData.map(d => d.confidence || 0)),
            data: session.gazeData,
            config: session.config
          };

          store.add(sessionData).onsuccess = () => {
            logMessage("Session data saved successfully", 'success');
            loadSessions(); // Refresh sessions list
          };
        }
        
        // Clear current session
        dataStorage.clearSession();
        
        // Update UI
        updateUIState(false);
        document.getElementById("liveData").innerHTML = "<em>Live gaze data will appear here...</em>";
        logMessage("Eye tracking stopped.");
      } catch (error) {
        console.error("Error stopping tracking:", error);
        logMessage("Error stopping tracking: " + error.message, 'error');
      }
    }

    // Monitor calibration timeout
    setInterval(() => {
      if (isCalibrating && calibrationStartTime > 0) {
        const calibrationDuration = Date.now() - calibrationStartTime;
        if (calibrationDuration > CALIBRATION_TIMEOUT) {
          logMessage("❌ Calibration timeout reached", 'error');
          handleCalibrationFailure();
        }
      }
    }, 1000);

    // Handle gaze data processing
    function handleGazeData(GazeData) {
      try {
        if (!tracking || !dataCollectionReady) return;

        const processedData = processGazeData(GazeData);
        if (!processedData) return;

        recordedData.push(processedData);
        if (recordedData.length > MAX_RECORDED_POINTS) {
          recordedData = recordedData.slice(-MAX_RECORDED_POINTS);
          logMessage("Trimming recorded data to prevent memory issues", 'warning');
        }

        updateLiveData(processedData);
        
        if (recordedData.length % 50 === 0) {
          const avgConfidence = mean(recordedData.slice(-50).map(d => d.confidence || 0));
          logMessage(
            `Recording active: ${recordedData.length} points collected | ` +
            `Recent Quality: ${(avgConfidence * 100).toFixed(1)}% | ` +
            `Rate: ${(50000 / (Date.now() - lastUpdate)).toFixed(1)} Hz`,
            avgConfidence > DATA_QUALITY_THRESHOLD ? 'success' : 'warning'
          );
        }
      } catch (error) {
        console.error("Error processing gaze data:", error);
        logMessage("Error processing gaze data: " + error.message, 'error');
      }
    }

    // Handle calibration failure
    function handleCalibrationFailure() {
      isCalibrating = false;
      tracking = false;
      dataCollectionReady = false;
      
      document.getElementById("liveData").innerHTML = `
        <div class="calibration-message error">
          <h3>Calibration Failed</h3>
          <p>Please ensure:</p>
          <ul>
            <li>Your face is well-lit and visible</li>
            <li>You are in a stable position</li>
            <li>Your eyes are clearly visible</li>
            <li>You are looking at the calibration points</li>
          </ul>
          <p>Click "Start Tracking" to try again.</p>
        </div>
      `;
      
      logMessage(`Calibration failed (Attempt ${calibrationAttempts} of ${MAX_CALIBRATION_ATTEMPTS})`, 'error');
      updateUIState(false);
    }

    // Handle GazeCloud API errors with enhanced error handling
    function handleGazeError(error) {
      try {
        tracking = false;
        isCalibrating = false;
        dataCollectionReady = false;
        
        // Enhanced error logging
        debugLog('Handling gaze error:', {
          code: error.code,
          message: error.message,
          originalError: error.originalError
        });
        
        // Reset calibration attempts if it's a camera error
        if (error.code === ERROR_CODES.CAMERA_DENIED) {
          calibrationAttempts = 0;
        }

        // Log the error with appropriate level
        console.error("GazeCloud API Error:", error);
        logMessage(error.message || "Unknown error occurred", 'error');
        
        // Update UI state
        updateUIState(false);
        
        // Show detailed error message with troubleshooting steps
        const errorMessages = {
          [ERROR_CODES.CAMERA_DENIED]: `
            <div class="calibration-message error">
              <h3>❌ Camera Access Denied</h3>
              <p>The eye tracker needs access to your camera. Please:</p>
              <ol>
                <li>Check if your camera is properly connected</li>
                <li>Allow camera access in your browser settings</li>
                <li>Make sure no other application is using your camera</li>
                <li>Try using a different camera if available</li>
              </ol>
              <p>Once you've checked these, click "Start Tracking" to try again.</p>
            </div>
          `,
          [ERROR_CODES.CONNECTION_ERROR]: `
            <div class="calibration-message error">
              <h3>❌ Connection Error</h3>
              <p>Lost connection to the eye tracking service. Please:</p>
              <ol>
                <li>Check your internet connection</li>
                <li>Ensure you have a stable network connection</li>
                <li>Try refreshing the page</li>
                <li>If the problem persists, try again in a few minutes</li>
              </ol>
              <p>Technical details: ${error.message}</p>
            </div>
          `,
          [ERROR_CODES.API_NOT_FOUND]: `
            <div class="calibration-message error">
              <h3>❌ Connection Error</h3>
              <p>Could not connect to the eye tracking service. Please:</p>
              <ol>
                <li>Check your internet connection</li>
                <li>Disable any ad blockers or privacy extensions</li>
                <li>Try refreshing the page</li>
              </ol>
              <p>Technical details: ${error.message}</p>
            </div>
          `,
          [ERROR_CODES.INITIALIZATION_ERROR]: `
            <div class="calibration-message error">
              <h3>❌ Initialization Error</h3>
              <p>The eye tracking system failed to initialize. Please ensure:</p>
              <ol>
                <li>Your browser is up to date (Chrome recommended)</li>
                <li>You have a working webcam</li>
                <li>Your system meets the minimum requirements</li>
                <li>Try clearing your browser cache and cookies</li>
              </ol>
              <p>Technical details: ${error.message}</p>
            </div>
          `,
          'default': `
            <div class="calibration-message error">
              <h3>❌ Eye Tracking Error</h3>
              <p>An error occurred with the eye tracking system. Please:</p>
              <ol>
                <li>Check your camera and internet connection</li>
                <li>Ensure proper lighting conditions</li>
                <li>Make sure your face is clearly visible</li>
                <li>Try refreshing the page</li>
              </ol>
              <p>Technical details: ${error.message}</p>
            </div>
          `
        };

        // Display the appropriate error message
        document.getElementById("liveData").innerHTML = 
          errorMessages[error.code] || errorMessages['default'];

        // If it's a critical error, suggest page refresh
        if (error.code === ERROR_CODES.API_NOT_FOUND || 
            error.code === ERROR_CODES.API_LOAD_TIMEOUT ||
            error.code === ERROR_CODES.CONNECTION_ERROR) {
          setTimeout(() => {
            if (confirm('Would you like to refresh the page to try again?')) {
              window.location.reload();
            }
          }, 1000);
        }

      } catch (e) {
        console.error("Error in handleGazeError:", e);
        document.getElementById("liveData").innerHTML = `
          <div class="calibration-message error">
            <h3>❌ Critical Error</h3>
            <p>A critical error occurred. Please refresh the page and try again.</p>
            <p>Error details: ${e.message}</p>
          </div>
        `;
      }
    }

    // Validate and process incoming gaze data
    function processGazeData(gazeData) {
      try {
        if (!gazeData || typeof gazeData !== 'object') return null;
        
        // Validate timestamp and ensure proper interval
        const currentTime = Date.now();
        if (lastDataPoint && (currentTime - lastDataPoint.timestamp) < MIN_DATA_INTERVAL) {
          return null;
        }

        // Process and validate coordinates
        const processedData = {
          timestamp: currentTime,
          x: gazeData.docX !== undefined ? gazeData.docX : gazeData.x,
          y: gazeData.docY !== undefined ? gazeData.docY : gazeData.y,
          state: gazeData.state,
          confidence: gazeData.confidence || 0,
          pupilD: gazeData.pupilD,
          HeadX: gazeData.HeadX,
          HeadY: gazeData.HeadY,
          HeadZ: gazeData.HeadZ,
          HeadYaw: gazeData.HeadYaw,
          HeadPitch: gazeData.HeadPitch,
          HeadRoll: gazeData.HeadRoll
        };

        // Validate data quality
        if (processedData.confidence < DATA_QUALITY_THRESHOLD) {
          logMessage("Low confidence data point detected", 'warning');
          return null;
        }

        lastDataPoint = processedData;
        return processedData;
      } catch (error) {
        console.error("Error processing gaze data:", error);
        logMessage("Error processing gaze data: " + error.message, 'error');
        return null;
      }
    }

    // Export the recorded gaze data as a CSV file
    function exportCSV() {
      try {
        if (recordedData.length === 0) {
          logMessage("No data recorded to export.");
          return;
        }
        let csvContent = "data:text/csv;charset=utf-8,";
        csvContent += "timestamp,x,y,state,confidence,pupilD,HeadX,HeadY,HeadZ,HeadYaw,HeadPitch,HeadRoll\n";
        
        recordedData.forEach(function(data) {
          const timestamp = data.time || data.timestamp || '';
          const x = data.docX !== undefined ? data.docX : data.x || '';
          const y = data.docY !== undefined ? data.docY : data.y || '';
          const state = data.state || '';
          const confidence = data.confidence || '';
          const pupilD = data.pupilD || '';
          const HeadX = data.HeadX || '';
          const HeadY = data.HeadY || '';
          const HeadZ = data.HeadZ || '';
          const HeadYaw = data.HeadYaw || '';
          const HeadPitch = data.HeadPitch || '';
          const HeadRoll = data.HeadRoll || '';
          
          csvContent += `${timestamp},${x},${y},${state},${confidence},${pupilD},${HeadX},${HeadY},${HeadZ},${HeadYaw},${HeadPitch},${HeadRoll}\n`;
        });

        const encodedUri = encodeURI(csvContent);
        const link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", "gaze_data_" + Date.now() + ".csv");
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        logMessage("CSV export completed.");
      } catch (error) {
        console.error("Error in exportCSV:", error);
        logMessage("Failed to export CSV: " + error.message);
      }
    }

    // Clear recorded data and reset the live display
    function clearData() {
      try {
        recordedData = [];
        document.getElementById("liveData").innerHTML = "<em>Live gaze data will appear here...</em>";
        logMessage("Cleared recorded data.");
      } catch (error) {
        console.error("Error in clearData:", error);
      }
    }

    /********** CSV ANALYSIS DASHBOARD SECTION **********/
    // Compute basic statistics from CSV data
    function computeBasicStats(data) {
      try {
        const validConfidence = data.filter(d => d.confidence !== undefined && d.confidence !== null && d.confidence !== '');
        const validPupilData = data.filter(d => d.pupilD !== undefined && d.pupilD !== null && d.pupilD !== '');
        const validHeadData = data.filter(d => 
          d.HeadX !== undefined && d.HeadY !== undefined && d.HeadZ !== undefined &&
          d.HeadX !== null && d.HeadY !== null && d.HeadZ !== null &&
          d.HeadX !== '' && d.HeadY !== '' && d.HeadZ !== ''
        );

        let avgConfidence = validConfidence.length ? (mean(validConfidence.map(d => d.confidence)) * 100).toFixed(1) + '%' : 'N/A';
        let pupilMean = validPupilData.length ? mean(validPupilData.map(d => d.pupilD)).toFixed(2) : 'N/A';
        let pupilMin = validPupilData.length ? Math.min(...validPupilData.map(d => d.pupilD)).toFixed(2) : 'N/A';
        let pupilMax = validPupilData.length ? Math.max(...validPupilData.map(d => d.pupilD)).toFixed(2) : 'N/A';
        let pupilStdDev = validPupilData.length ? standardDeviation(validPupilData.map(d => d.pupilD)).toFixed(2) : 'N/A';

        let headXMean = validHeadData.length ? mean(validHeadData.map(d => d.HeadX)).toFixed(1) : 'N/A';
        let headYMean = validHeadData.length ? mean(validHeadData.map(d => d.HeadY)).toFixed(1) : 'N/A';
        let headZMean = validHeadData.length ? mean(validHeadData.map(d => d.HeadZ)).toFixed(1) : 'N/A';

        return {
          avgConfidence,
          pupilMean,
          pupilMin,
          pupilMax,
          pupilStdDev,
          headXMean,
          headYMean,
          headZMean
        };
      } catch (error) {
        console.error("Error computing basic stats:", error);
        return null;
      }
    }

    // Update GazeCloud API callbacks with proper error handling
    function initializeGazeTracking() {
      try {
        // Configure GazeCloud API settings
        GazeCloudAPI.APIKey = "GazeCloudAPI-Key"; // Replace with your API key
        GazeCloudAPI.CalibrationType = 5; // 5-point calibration
        GazeCloudAPI.ShowVideo = true;
        GazeCloudAPI.UseClickRecalibration = true;
        GazeCloudAPI.Debug = DEBUG;
        
        // Set up error handling callbacks
        GazeCloudAPI.OnCamDenied = function() {
          handleGazeError({
            code: ERROR_CODES.CAMERA_DENIED,
            message: "Camera access was denied by the browser or user."
          });
        };

        GazeCloudAPI.OnError = function(error) {
          debugLog('GazeCloud API error received:', error);
          
          let errorMessage = "Unknown GazeCloud API Error";
          let errorCode = ERROR_CODES.INITIALIZATION_ERROR;
          
          try {
            // Handle different error formats
            if (typeof error === 'object') {
              if (error instanceof Error) {
                errorMessage = error.message;
              } else if (error !== null) {
                errorMessage = JSON.stringify(error, Object.getOwnPropertyNames(error));
              }
            } else if (typeof error === 'string') {
              errorMessage = error;
            }
            
            // Determine error type
            if (errorMessage.toLowerCase().includes('camera')) {
              errorCode = ERROR_CODES.CAMERA_DENIED;
            } else if (errorMessage.toLowerCase().includes('connection') || 
                      errorMessage.toLowerCase().includes('websocket')) {
              errorCode = ERROR_CODES.CONNECTION_ERROR;
            }
            
            debugLog('Processed error:', { code: errorCode, message: errorMessage });
          } catch (e) {
            console.error('Error processing GazeCloud error:', e);
            errorMessage = "Failed to process error details";
          }
          
          handleGazeError({
            code: errorCode,
            message: `GazeCloud API Error: ${errorMessage}`,
            originalError: error
          });
        };

        GazeCloudAPI.OnCalibrationFail = function() {
          handleCalibrationFailure();
        };

        return true;
      } catch (error) {
        console.error("Error initializing gaze tracking:", error);
        handleGazeError({
          code: ERROR_CODES.INITIALIZATION_ERROR,
          message: "Failed to initialize eye tracking: " + error.message
        });
        return false;
      }
    }
  </script>
</head>
<body>
  <!-- Rest of the HTML content remains unchanged -->
</body>
</html>
